---
layout: post
title: Computing Systems for Machine Learning
date: 2022-01-02 12:18 +0800
tags: [Programming]
toc:  true
---

<!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TG0XJZG53F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-TG0XJZG53F');
  </script>

## Chapter 1 Introduction

skipped :3

## Chapter 2 Python Fundamentals

### Syntax

#### hello. py

Python does not have a main method like Java

-The program's main code is just written directly in the file

Python statements do not end with semicolons

```py
print("Hello, world!")
```

#### Multi-Line Statements

Statements in Python typically end with a new line. Python does, however, allow the use of the line continuation character (\\) to denote that the line should continue. For example:

```py
total = item_one + \
        item_two + \
        item_three
```
Statements contained within the [], {}, or () brackets do not need to use the line continuation character. For example:

```py
days = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday']
```

#### Quotation in Python

Python accepts single ('), double (") and triple (''' or """) quotes to denote string literals, as long as the same type of quote starts and ends the string

The triple quotes can be used to span the string across multiple lines. For example, all the following are legal:

```py
word = 'word'
sentence = "This is a sentence."
paragraph = """This is a paragraph. It is made up
  of multiple lines and sentences."""
```

#### Comments

As programs get bigger and more complicated, they become more difficult to read

It is a good idea to add notes to your programs

A # symbol that is not inside a string starts a comment

All characters after the # and up to the physical line end are part of the comment

Python interpreter ignores them


#### Using Blank Lines

A line containing only whitespace, possibly with a comment, is known as a blank line, and is ignored by the Python interpreter

In an interactive interpreter session, you must enter an empty physical line to terminate a multiline statement


#### Multiple Statements on a Single Line

The semicolon ( ; ) allows multiple statements on the single line given that neither statement starts a new code block. Here is a sample snip using the semicolon:

```py
import sys; x = 'foo'
```

#### Multiple Statement Groups as Suites

Groups of individual statements making up a single code block are called suites in Python

Compound or complex statements, such as if, while, def, and class, are those which require a header line and a suite

Header lines begin the statement (with the keyword) and terminate with a colon ( : ) and are followed by one or more lines which make up the suite

```py
if expression1 :
suite1
elif expression2 :
  suite2
else :
  suite3
```

#### Suites and Indentation

One of the first caveats programmers encounter when learning Python is that there are no braces to indicate blocks of code for class and function definitions or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced

The number of spaces in the indentation is variable, but all statements within the block must be indented the same amount

```py
if x == True:
  print ("Answer")
  print ("True")
else:
  print ("Answer")
  print ("False")
```

#### Reserved Words

Keywords contain lowercase letters only
```
and exec not
assert finally or
break for pass
class from print
continue global raise
def if return
del import try
elif in while
else is with
except lambda yield
```

### Variables and Expressions

#### Variable Name

Variable names can be both letters and numbers

They have to begin with a letter though

Uppercase letters are allowed, generally we use lowercase

Underscore character (_) can also appear in a name

Variable name cannot be a keyword

An illegal name results in a syntax error


#### Assigning Values to Variables

Python variables do not have to be explicitly declared to reserve memory space

The declaration happens automatically when you assign a value to a variable.

The equal sign (=) is used to assign values to variables

```py
counter = 100  # An int assignment
miles = 1000.0 # A float
name = "John"  # A str
print (counter)
print (miles)
print (name)
```

#### Constants

Python doesn't really have constants

Instead, declare a "global" variable at the top of your code

All methods will be able to use this value

```py
MAX_VALUE = 3
```

#### Multiple Assignments

You can also assign a single value to several variables simultaneously

```py
a = b = c = 1
a, b, c = 1, 2, "john"
```

#### Data Types

Number types

• int

• float

• complex

Sequence type

• str (immutable)

• list

• tuple (immutable)

• range

• zip (sequence of tuples)

Boolean type

• bool

Set type

• set

• frozenset

Mapping type

• dict

Binary type

• bytes

• bytearray

• memoryview

#### Data Types: Java vs Python

Python is looser about types than Java

Variables' types do not need to be declared

Variable can change type as a program is running

If the variable value is set to a value of a different type

```py
a = 1       # integer type
a = "john"  # string type
```

#### Expressions and Statements

An expression is a combination of values, variables, and operators

A value or variable all by itself is also an expression

```py
Examples
21
x
x+21
```

A statement is a unit of code that a Python interpreter can execute, for example,

• print

• assignment

#### Operators and Operands

Operators represent computations like addition, multiplication, division, etc.

\+  -  *  /  %  **

The values the operator is applied to are called operands

```py
>>> 1 + 1
2
>>> 1 + 3 * 4 - 2
11
>>> 7 / 2
3
>>> 7.0 / 2
3.5
>>> 10 ** 6
1000000
```

#### Modulus Operator

Works on integers
Yields the remainder of the first operand divided by the second

Indicated by %

• Quotient = 7 // 3

• Remainder = 7 % 3

Utility: find the last digits of a number

```py
>>> 97856 % 100
56
```

#### Order of Operations

When multiple operators appear in an expression, the order of evaluation depends on the rules of precedence

Multiplication and division have the same precedence; addition and subtraction have the same precedence

Operators with the same precedence are evaluated from left to right (except exponentiation which has right-to-left precedence)

#### Operators: Java vs Python

No ++ or -- operators (must manually adjust by 1)

Java
```Java
nt x = 2;
x++;
System.out.println(x);
x = x * 8;
System.out.println(x);
double d = 3.2;
d = d / 2;
System.out.println(d);
```

Python
```py
x = 2
x = x + 1
print(x)
x = x * 8
print(x)
d = 3.2
d = d / 2
print(d)
```

#### str Data Type

Strings in Python are identified as a contiguous set of characters in between quotation marks

Python allows for either pairs of single or double quotes. Subsets of strings can be taken using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the string and working their way from -1 at the end

The plus ( + ) sign is the string concatenation operator, and the asterisk (*) is the repetition operator

```py
str1 = 'Hello World!'
print str1 # Prints complete string
print str1[0] # Prints first character of the string
print str1[2:5] # Prints characters starting from 3rd to 6th
print str1[2:] # Prints string starting from 3rd character
print str1 * 2 # Prints string two times
print str1 + "TEST" # Prints concatenated string

Output:
Hello World!
H
llo
llo World!
Hello World!Hello World!
Hello World!TEST
```

#### String Operations

You can’t perform mathematical operations on strings

Examples

• ‘2’ - ’1’

• ‘eggs’ / ‘dozens’

The + operator works with strings and performs concatenations

```py
first = 'hello'
second = 'class'
print(first + second)

Output:
helloclass
```

#### String Multiplication

The * operator works with strings and performs repetition

Examples

• ‘Spam’*3 is ‘SpamSpamSpam’

If one of the operands is a string, the other has to be an integer

```py
>>> "hello" * 3
"hellohellohello"
>>> print(10 * "yo ")
yo yo yo yo yo yo yo yo yo yo
>>> print(2 * 3 * "4")
444444
```

#### String Concatenation

Integers and strings cannot be concatenated in Python

str(value) - converts a value into a string

print(expr, expr)  - prints two items on the same line

```py
>>> x = 4
>>> print("Thou shalt not count to " + x + ".")
TypeError: cannot concatenate 'str' and 'int' objects
>>> print("Thou shalt not count to " + str(x) + ".")
Thou shalt not count to 4.
>>> print(x + 1, "is out of the question.")
5 is out of the question.
```

#### list Data Type

Lists are the most versatile of Python's compound data types. A list contains items separated by commas and enclosed within square brackets ([])

To some extent, lists are similar to arrays in C. One difference between them is that all the items belonging to a list can be of different data type

The values stored in a list can be accessed using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the list and working their way to end-1

The plus ( + ) sign is the list concatenation operator, and the asterisk ( * ) is the repetition operator

```py
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print list          # Prints complete list
print list[0]       # Prints first element of the list
print list[1:3]     # Prints elements starting from 2nd till 3rd
print list[2:]      # Prints elements starting from 3rd element
print tinylist * 2  # Prints list two times
print list + tinylist # Prints concatenated lists
Output:
['abcd', 786, 2.23, 'john', 70.2]
abcd
[786, 2.23]
[2.23, 'john', 70.2]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.2, 123, 'john']
```

#### tuple Data Type

A tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parentheses

The main differences between lists and tuples are: Lists are enclosed in brackets ( [ ] ), and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read-only lists

```py
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2  )
tinytuple = (123, 'john')

print(tuple)        # Prints complete list
print(tuple[0])        # Prints first element of the list
print(tuple[1:3])     # Prints elements starting from 2nd till 3rd
print tuple[2:]       # Prints elements starting from 3rd element
print tinytuple * 2   # Prints list two times
print tuple + tinytuple # Prints concatenated lists


OUTPUT:
('abcd', 786, 2.23, 'john', 70.2)
abcd
(786, 2.23)
(2.23, 'john', 70.2)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.2, 123, 'john')
```

#### dict Data Type

Python 's dictionaries are hash table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs

Keys can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object

Dictionaries are enclosed by curly braces ( { } ) and values can be assigned and accessed using square braces ( [] )

```py
dict = {}
dict['one'] = "This is one"
dict[2]     = "This is two“
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print(dict['one'])      # Prints value for 'one' key
print (dict[2])          # Prints value for 2 key
print (tinydict)         # Prints complete dictionary
print (tinydict.keys())  # Prints all the keys
print (tinydict.values()) # Prints all the values

OUTPUT:
This is one
This is two
{'dept': 'sales', 'code': 6734, 'name': 'john'}
['dept', 'code', 'name']
['sales', 6734, 'john']
```

#### Data Type Conversion

```py
Function Description
int(x [,base]) Converts x to an integer. base specifies the base if x is a string
long(x [,base] ) Converts x to a long integer. base specifies the base if x is a string
float(x) Converts x to a floating-point number
complex(real [,imag]) Creates a complex number
str(x) Converts object x to a string representation
repr(x) Converts object x to an expression string
eval(str) Evaluates a string and returns an object
tuple(s) Converts s to a tuple
list(s) Converts s to a list
set(s) Converts s to a set
dict(d) Creates a dictionary. d must be a sequence of (key,value) tuples
frozenset(s) Converts s to a frozen set
chr(x) Converts an integer to a character
unichr(x) Converts an integer to a Unicode character
ord(x) Converts a single character to its integer value
hex(x) Converts an integer to a hexadecimal string
oct(x) Converts an integer to an octal string
```

### Conditionals

#### Boolean Expressions

A boolean expression is an expression that is either true or false

It uses the operator '=\=', which compares the operands to the left and the right of this operator

It produces either True or False

• for example, 5=\=5 will return True

• and 5==6 will return False

True and False are of type bool

• x != y # x is not equal to y

• x > y # x is greater than y

• x < y # x is less than y

• x >= y # x is greater than or equal to y

• X <= y # x is less than or equal to y

#### Logical Operators

Three logical operators: and, or, and not. For example:

• x > 0 and x < 10

• This is true only if x is greater than 0 and less than 10

• n%2 == 0 or  n%3 == 0 is true if either of the conditions is true, that is, if the number is divisible by 2 or 3

• The not operator negates a boolean expression, so not(x > y) is true if x > y is false, that is, if x is less than or equal to y

#### Conditional Execution

We need to check conditions and change the behavior of the program

The simplest conditional statement is if, for example:

The Boolean expression after ‘if’ is called the condition
```py
if x>0:
  print('x is positive')

OUTPUT:
x is positive
```

#### if Statement

if statements have a header followed by an indented body

Statements like these are called compound statements

There is no limit on the number of statements that can appear in the body, but there must be at least one

Sometimes it is useful to have a body with no statements, usually as a place holder

In that case use the pass statement, which does nothing

```py
if x < 0: pass  # need to handle negative values
```

#### Alternative Execution

When there are two possibilities and the condition determines which one gets executed

The alternatives are called branches, because they are branches in the flow of execution

```py
if x%2 == 0:
  print('x is even')
else:
  print('x is odd')
```

#### Chained Conditionals

Sometimes there are more than two possibilities and we need more than two branches

One way to express a computation like that is a chained conditional:
elif is an abbreviation of “else if”

```py
if(x <y):
  print('x is less than y')
elif(x>y):
  print('x is greater than y')
else:
  print('x and y are equal')
```

There is no limit to the number of elif statements

If there is an else clause, it must be at the end

Each condition is checked in order. If the first one is false, the next is checked, and so on

We don’t need an else statement:

```py
if choice == 'a':
  draw_a()
elif choice == 'b':
  draw_b()
elif choice == 'c':
  draw_c()
```

### Functions

#### Function

A function is some reusable code that

• takes arguments(s) as input

• does some computation and

• returns a result or results

There are two kinds of functions in Python

• Built-in functions that are provided as part of Python - raw_input(), type(), float(), int() ...

• Functions that we define ourselves and then use

We treat the built-in function names as "new" reserved words (i.e., we avoid them as variable names)

#### A Built-in Function: max()

A built-in function is some stored code that we use. It takes some input and produces an output.

```py
>>> big = max('Hello world')
>>> print big
'w'
```

#### Type Conversion Functions

There are built-in functions in Python that convert from one data type to another

• The int() function takes any value and converts it into an integer, if it can

• int() can convert floating-point values to integers, but it doesn’t round off, and instead chops off the fraction part

• float() converts integers and strings to floating-point numbers

• str() converts its arguments to string

#### Math Functions

Python has a math module that provides mathematical functions

Before using the module, it needs to be imported `import math`

This module contains the functions and variables defined in the module

To access one of the functions, you have to specify the name of the module and the name of the function

#### Import

Python provides 2 ways to import modules

• We have already seen  import math

• import statement imports all the functions from a module into the code

We can also import functions using  from

• Imports only the specified function

• Syntax

  from [module] import [function or value]

  from random import choice

#### Counting and Iterating Functions

len: returns the number of items of an enumerable object

```py
>>> len( [‘c’, ‘m’, ‘s’, ‘c’, 3, 2, 0] )
7
```

range: returns an iterable object

```py
>>> list( range(10) )
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

enumerate: returns iterable tuple (index, element) of a list

```py
>>> enumerate( [“311”, “320”, “330”] )
[(0, “311”), (1, “320”), (2, “330”)]
```

map: apply a function to a sequence or iterable

```py
>>>arr = [1, 2, 3, 4, 5]
>>>map(lambda x: x**2, arr)
[1, 4, 9, 16, 25]
```

```py
>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
[3, 7, 11, 15, 19]
```
filter: returns a list of elements for which a predicate is true

```py
>>>arr = [1, 2, 3, 4, 5, 6, 7]
>>> filter(lambda x: x % 2 == 0, arr)
[2, 4, 6]
```

#### User-Defined Functions

A named sequence of statements that perform a certain computation

After defining a function, you can call it by name

• Example: type(34)

Why Define & Use Functions?

• A group of statements gets a name

• Modular code

• Easier debugging

• Code reuse

```py
# Prints a helpful message.
def hello():
  print("Hello, world!")
# main (calls hello twice)

hello()
hello()
```
Must be declared above the 'main' code

Statements inside the function must be indented

#### Whitespace Significance

Python uses indentation to indicate blocks, instead of {}

• Makes the code simpler and more readable

• In Java, indenting is optional.  In Python, you must indent

```py
# Prints a helpful message.
def hello():
  print("Hello, world!")
# main (calls hello twice)

hello()
hello()
```

#### Arguments, Parameters, Variables

Most functions require arguments

• E.g.: math functions

An expression can also be used as an argument

Inside the function, arguments are assigned to variables called parameters

• Parameters are local to the function

Some functions return a value and others return nothing (void)

A variable created inside a function is local

```py
def summation(x,y):
  z = x + y
  return(z)

print(summation(2,4))

m = summation(2,4)
print(m)
```

```py
def decide(x,y):
  if x=='green’ and y=='Red’:  
    print("You can go!")

y = 'Red'
y = 'green'
y = 'green'
z = 'Red'

decide(z,y)
```

### Iterations

#### Iterations

Involves repetition

A statement or group of statements that need to be repeated

Help in automation of repeated tasks

#### The for Loop

Uses an iterator (name) and repeats for values 0 (inclusive) to max (exclusive)

```py
for name in range(max):
    statements
```

```py
>>> for i in range(5):
...     print(i)
0
1
2
3
4
```

#### for Loop Variations

Can specify a min other than 0, and a step other than 1

```py
for name in range(min, max):
    statements

for name in range(min, max, step):
    statements
```

```py
>>> for i in range(2, 6):
...     print(i)
2
3
4
5
>>> for i in range(15, 0, -5):
...     print(i)
15
10
5
```

#### Nested Loops

Nested loops are often replaced by string * and +

```py
for line in range(1, 6):
  print((5 - line) * "." + str(line))

output:
....1
...2
..3
.4
5
```

```py
def bar():
  print "#" + 16 * "=" + "#"
def top():
  for line in range(1, 5):        # split a long line by ending it with \     
    print("|" + (-2 * line + 8) * " " + \             
         "<>" + (4 * line - 4) * "." + "<>" + \              
         (-2 * line + 8) * " " + "|")
def bottom():    
  for line in range(4, 0, -1):        
    print("|" + (-2 * line + 8) * " " + \              
         "<>" + (4 * line - 4) * "." + "<>" + \              
         (-2 * line + 8) * " " + "|")

# main
bar()
top()
bottom()
bar()

```
```
output:
#================#
|      <><>      |
|    <>....<>    |
|  <>........<>  |
|<>............<>|
|<>............<>|
|  <>........<>  |
|    <>....<>    |
|      <><>      |
#================#
```

#### Concatenating Ranges

Ranges can be concatenated with +

• Can be used to loop over a disjoint range of numbers

```py
>>> range(1, 5) + range(10, 15)
[1, 2, 3, 4, 10, 11, 12, 13, 14]

>>> for i in range(4) + range(10, 7, -1):
...     print(i)
0
1
2
3
10
9
8
```

#### while Loop

In the definition there is no starting iterator

We need to use a condition with the while

It requires a condition, e.g.,

```py
n = 12
while(n >0):
  print(n)
  n = n - 1
```

#### Execution Flow for a while Loop

At the start of each iteration, evaluate the condition, yielding True or False

If the condition is false, exit the while statement and continue execution at the next statement

If the condition is true, execute the body and then go to the condition again

The body of the loop will change the value of one or more variables so that condition eventually becomes false and the loop terminates

#### break Statement

Sometimes we want to break out of a loop if some

condition is satisfied

```py
n = 12
while(n >0):
  print(n)
  n = n - 1
  if n == 7:
    break

output:
12
11
10
9
8
```

## Chapter 3 Python Advanced

### Strings

#### String

A sequence type

A sequence of zero or more characters

  course = “MSML 605”

A string is delimited (begins and ends) by single or double quotes

The empty string has zero characters ('' or "")

```py
poem = 'Ode to a Nightingale'
lyric = "Roll on, Columbia, roll on"
exclamation = "That makes me !#? "
```

Quote Characters in Strings

 You can include a single quote in a double quoted string or a double quote in a single quoted string

```py
will = "All the world's a stage"
ben = 'BF: "A penny saved is a penny earned"'
```

 To put a single quote in a single quoted string, precede it with the backslash ('\\') or 'escape' character.  

```py
>>> will = 'All the world\'s a stage'
>>> print(will)
All the world's a stage
```

 The same goes for double quotes

```py
>>> ben = "BF: \"A penny saved is a penny earned\""
>>> print(ben)
BF: "A penny saved is a penny earned"
```

Putting a Format Character in a String

 A format character is interpreted by the print() function to change the layout of text

 To put a format character in a string, precede it with the backslash ('\')

 A newline is represented by '\n'  

```py
>>> juliette = 'Good night, good night\nParting is such sweet sorrow'
>>> print(juliette)
Good night, good night
Parting is such sweet sorrow
```

 A tab is represented by '\t'

```py
>>> tabs = 'col0\tcol1\tcol2'
>>> print(tabs)
col0 col1 col2
```

#### Bracket operator and Index

You can access the characters one at a time with the bracket operator

The first character has index 0

`second_character = course[1]`

```py
>>> course = "MSML 605"
>>> second_character = course[1]
>>> print(second_character)
S
```
index has to be an integer

#### Negative Indices

Using negative indices: counts backwards from the string end

```py
>>> course[-1]
5
```

#### len() Function

last index using length

```py
>>> len(course)
8
```

#### Traversal with while

Processing one character at a time

```py
course = "MSML 605"
index = 0
while index < len(course):
  letter = course[index]
  print(letter)
  index +=1

output:
M
S
M
L

6
0
5
```

#### Traversal with for

A more Pythonic way to traverse a string using for

```py
course = "MSML 605"
for c in course:
  print(c)

output:
M
S
M
L

6
0
5
```

```py
course = "MSML 605"
for c in course:
  print(c, end = ' ')

output:
M S M L   6 0 5
```

#### String Concatenation

Two strings can be concatenated using the ‘+’ operator

```py
word1 = 'abc'
word2 = 'def'
word = word1 + word2
print(word)

output:
abcdef
```

#### String Slices

A segment of a string is a slice

Selecting a slice is similar to selecting a character

The operator [n:m] returns the part of the string from the “n-eth” character to the “m-eth” character

It includes the first but excludes the last

```py
>>> greeting = 'hello, world'
>>> greeting[1:3]
'el'
>>> greeting[-3:-1]
'rl'
```

If the first index before the colon is omitted, the slice starts at the beginning of the string.

If you omit the second index, the slice goes to the end of the string

```py
>>> print(greeting[:4], greeting[7:])
hell world
```

If the first index >= second index, the result is an empty string

You can pick every kth element if you like

```py
>>> greeting[3:10:2]
'l,wr'
```

#### Strings Are Immutable

Once created, a string cannot be modified

What happens if [ ] operators are used on the left side of the assignment operator?

```py
>>> greeting = 'hello, world'
>>> greeting = 'J' + greeting[1:]
>>> greeting
'Jello, world'
```

#### String Search

find is the opposite of the [ ] operator

Instead of taking an index and extracting the corresponding character, it takes a character and finds an index

```py
def find(word,letter):
  index = 0
  while index < len(word):
    if word[index] == letter:
      return(index)
    index +=1
  return(-1)
```

#### Looping and Counting

The following program counts the number of times the letter ‘a’ appears in a string

```py
word = 'banana'
count = 0
for leter in word:
  if letter == 'a':
    count +=1
print(count)

output:
3
```

#### upper() Method

A method is a function that is bundled together with an object: it takes arguments and returns a value

A method call is called an invocation

We are invoking upper() on word

```py
word = 'banana'
word = word.upper()
word

OUTPUT
'BANANA'
```

#### find() Method

There is a string method named ‘find()’

We invoke find() on word

```py
word = 'banana'
index = word.find('a')
print (index)  # will print 1, the first instance of 'a'
```

find() can also find substrings not just characters

`word.find('na')`

It can take as a second argument the index where it

should start:

`word.find(‘na’,3)`

As a third argument the index where it should stop:

```py
name = ‘bob’
name.find(‘b’,1,2)
```

#### in Operator

The word ‘in’ is a Boolean operator that takes two strings and returns true if the first appears as a substring in the second

`‘a’ in ‘banana’`

`‘seed’ in ‘banana’`

#### String Comparison

Relational operators work on strings

Equality operator ‘==’

Other relational operations are useful for putting words in alphabetical order:

```py
if word < 'banana’:
   print('Your word, ' + word + ', comes before banana.')
elif word > 'banana’:
   print('Your word, ' + word + ', comes after banana.')
else:
   print('All right, bananas.')
```

#### String Operationss

• "hello"+"world" "helloworld"      # concatenation

• "hello"*3 "hellohellohello" # repetition

• "hello"[0] "h"      # indexing

• "hello"[-1] "o"      # (from end)

• "hello"[1:4] "ell"      # slicing

• len("hello") 5      # size

• "hello" < "jello" 1      # comparison

• "e" in "hello" 1      # search

• New line:  "escapes: \n "

• Line continuation:  triple quotes ’’’

• Quotes:  ‘single quotes’, "raw strings"

#### String Methods

• upper()

• lower()

• capitalize()

• count(s)

• find(s)

• rfind(s)

• index(s)

 strip(), lstrip(), rstrip()

 replace(a, b)

 expandtabs()

 split()

 join()

 center(), ljust(), rjust()

### Lists

A sequence type

A sequence of values

These values can be of any type

Values in a list are called items or elements


#### Lists are Mutable

The syntax for accessing list elements is the same as for accessing string characters

The expression inside brackets specifies the index

```py
>>> numbers = [7, 34, 56]
>>> numbers[1] = 36        # list is mutable
>>> print(numbers)
[7, 36, 56]
```

#### Mapping

You can think of a list as a mapping between indices and elements

Each index “maps to” one of the elements

`num = [2, 34, 56]`

#### Indices

List indices work the same way as string indices

• Any integer expression can be used as an index

• if you try to read or write an element that does not exist, you get an IndexError

• If an index has a negative value, it counts backward from the end of the list

#### ‘in’ Operator

The ‘in’ operator also works on lists

```py
cheeses = [“Cheddar”, “Mozzarella”, “Blue”]
“Blue” in cheeses   # True
“Brie” in cheeses   # False
```

#### Traversing a List

The most common way is with a ‘for’ loop

Syntax is the same as for strings

This works well if you only need to read the elements

```py
cheeses = [“Cheddar”, “Mozzarella”, “Blue”]
for cheese in cheeses:
    print(cheese)
```

If you want to write or update the elements, you need the indices

Common way is to combine functions ‘range’ and ‘len'

This loop traverses the list and updates each element

```py
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
```

#### Nested Lists

A list can contain another list

`[‘spam’, 1, [‘Brie’, 5, 3.2], 2, [2, 5, 6]]`

Each internal list still counts as a single element

#### List Operations

‘+’ operator concatenates lists

```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
```

‘*’ operator repeats a list a given number of times

```py
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

#### List Slices

Slice operator also works on lists

```py
>>> t = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]
>>> t[1:3]
[‘b’, ‘c’]
>>> t[:4]
[‘a’, ‘b’, ‘c’, ‘d’]
>>> t[3:]
[‘d’, ‘e’, ‘f’]
```

If you omit the first index, the slice starts at the beginning

If you omit the second, the slice goes to the end

If you omit both, the slice is a copy of the whole list

```py
>>> t[:]
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]
```

#### append() Method

Python provides methods that operate on lists

append adds a new element to the end of a list

```py
>>> t = [‘a’, ‘b’, ‘c’]
>>> t.append(‘d’)
>>> print(t)
[‘a’, ‘b’, ‘c’, ‘d’]
```

#### extend() Method

extend takes a list as an argument and appends all of the elements

t2 is unmodified

```py
>>> t1 = [‘a’, ‘b’, ‘c’]
>>> t2 = [‘d’, ‘e’]
>>> t1.extend(t2)       # append list t2 to t1
>>> print(t1)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
```

#### sort() Method

sort arranges the elements of the list from low to high

List methods are all void; they modify the list and return None

```py
>>> t = [‘d’, ‘b’, ‘c’, ‘a’, ‘e’]
>>> t.sort()
>>> print(t)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
```

```py
# Create a list t, 1,5,6,7
t = [1,5,6,7]
# Print t
print (t)
# copy t to r list
r = t[:]
# not r = t, will only create another pointer to the list
# print r
print (r)
# Modify 2nd element of r
r[1] = 4
# print r
print (r)
# print t
print (t)
# What do you notice?
# t[1] and r[1] are different
r = t[:]
```

#### Deleting Elements

pop() - takes the last element

```py
 >>> t = ['a', 'b', 'c']
 >>> x  = t.pop()
 >>> x
 'c'
```

pop() modifies the list and returns the element that was removed

`t.pop(0)` removes the first element

del statement also deletes elements, when you don’t need them
`del t[1]`

#### remove() Method

If you know the element you want to remove (but not the index), use remove():

```py
t = ['a', 'b', 'c']
t.remove('b')
```

The return value from remove is None

To remove more than one element, use del statement

```py
t = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
del t[1:5]
```

#### Strings vs. Lists

• A string is a sequence of characters

• A list is a sequence of values

• A list of characters is not the same as a string

• A string is immutable whereas a list is mutable

```py
>>> s = 'spam'
>>> t = list(s)
>>> print(t)
['s','p','a','m']
```

#### split() Method

split() method takes a string and parses its words to form a list of strings

```py
>>> s = 'This is an ML class'
>>> t = s.split()
>>> print(t)
['This', 'is', 'an', 'ML', 'class']
```

#### Delimiter

A delimiter specifies which characters to use as word boundaries while splitting

```py
>>> s = 'spam-spam-spam'
>>> t = s.split('-')
>>> t
['spam', 'spam', 'spam']
```

#### join() Method

join() is the inverse of split()

It takes a list of strings and concatenates the elements to form a single string

```py
>>> t = ['This', 'is', 'an', 'ML', 'class']
>>> delimiter = ' '
>>> delimiter.join(t)
'This is an ML class'
```

#### Objects and Values

a and b both refer to a string, but we don’t know whether they refer to the same string

To determine, we can use the ‘is’ operator

```py
>>> a = ‘banana’
>>> b = ‘banana’
>>> a is b
True
```

When you create two lists, you get two distinct objects, even if they have the same elements

```py
>>> a = [1,2,3]
>>> b = [1,2,3]
>>> a is b
False

>>> b = a
>>> b is a
True

>>> b[0] =  17
>>> a
[17, 2, 3]
```

#### List Arguments

When you pass a list to a function, the function gets a reference to the list

If the function modifies a list parameter, the caller sees the change

Some operations modify lists and other operations create new lists

append() method modifies a list, but the + operator creates a new list

```py
t1 = [1,2]
t1.append(3)
t1
```

The difference is important when you write functions that are supposed to modify lists

```py
>>> t3 = t1 +[4]
>>> t3
[1, 2, 3, 4]
```

The slice operator creates a new list and the assignment makes t refer to it

```py
def bad_delete_head(t):
  t = t[1:]
t1 = [1,2,3]
bad_delete_head(t1)
t1

output:
[1, 2, 3]
```

None of that has any effect on the list passed as an argument

If we want to slice a list we can return it

The list leaves the original list unmodified

```py
def tail(t):
  return(t[1:])
t1 = [1, 2, 3]
t2 = tail(t1)
print(t1)
print(t2)

output:
[1, 2, 3]
[2, 3]
```

#### List Operations

 append

 insert

 index

 count

 sort

 reverse

 remove

 pop

 extend

• Indexing e.g., L[i]

• Slicing e.g., L[1:5]

• Concatenation e.g., L + L

• Repetition e.g., L * 5

• Membership test e.g., ‘a’ in L

• Length e.g., len(L)

#### List Comprehension

• List comprehensions offer a succinct way to create lists based on existing lists

• When using list comprehensions, lists can be built by leveraging any iterable, including strings and tuples

• Syntactically, list comprehensions consist of an iterable containing an expression followed by a for clause

• General Syntax

`[<output value> <iterator> <conditional stmt>]`

#### Squaring Numbers

Creating a list of squares of numbers from 1 to 5, without and with list comprehension

```py
squares = []
for i in range(1,6):
  squares.append(i**2)
squares

output:
[1, 4, 9, 16, 25]
```

```py
[x**2 for x in range(1,6)]

output:
[1, 4, 9, 16, 25]
```
Even numbers

```py
[x**2 for x in range(1,6) if x%2 == 0]

output:
[4, 16]
```

Odd numbers

```py
[x**2 for x in range(1,6) if x%2]

output:
[1, 9, 25]
```

#### Using if-else Conditionals

Make the values between 5 and 10 negative (both included)

```py
a = [3,4,5,6,7,8,9,10,1,12,13,14,15]
[-val if 5<=val <=10 else val for val in a]

output:
[3, 4, -5, -6, -7, -8, -9, -10, 1, 12, 13, 14, 15]
```

#### 2D List Creation w/out List Comprehension

```py
import random

data = []
for i in range(5):
  row = []
  for j in range(5):
    row.append(random.randint(1,10))
  data.append(row)

data

output:
[[2, 4, 8, 1, 5],
 [10, 1, 2, 8, 9],
 [7, 4, 1, 8, 2],
 [4, 2, 6, 2, 3],
 [10, 9, 7, 4, 10]]
```

#### 2D List Creation w/ List Comprehension

```py
import random

datal = [[random.randint(1,10) for j in range(5)] for i in range(5)]
datal

output:
[[5, 5, 8, 3, 5],
 [6, 5, 6, 10, 2],
 [8, 9, 7, 4, 9],
 [9, 10, 6, 2, 1],
 [10, 2, 1, 4, 8]]
```

#### Flattening 2D List

```py
datal_flattened = [val for row in datal for val in row]

datal_flattened

output:
[5, 5, 8, 3, 5, 6, 5, 6, 10, 2, 8, 9, 7, 4, 9, 9, 10, 6, 2, 1, 10, 2, 1, 4, 8]
```

### Tuples

#### Introduction

• A sequence type

• A sequence of values

• They are indexed and a lot like lists

• A comma-separated list of values

• It is common to enclose tuples in parentheses

```py
t = 'a', 'b', 'c' # or t = ('a', 'b', 'c')
t

output:
('a', 'b', 'c')
```

#### Tuples

What is a tuple?

• A sequence of values whose elements cannot be modified once it is created

• In other words, it's a read-only array

```py
>>> t = ()
>>> t = (1, 2, 3)
>>> t = (1, )
>>> t = 1,
>>> a = (1, 2, 3, 4, 5)
>>> print a[1]   # 2
```

#### List vs. Tuple

What are common characteristics?

• Both store arbitrary data objects

• Both are of sequence data type

What are differences?

• Tuple doesn’t allow modification

• Tuple doesn’t have methods??

• Tuple supports format strings

• Tuple supports variable length parameter in function call

• Tuple slightly faster


#### Tuples

To create a tuple with a single element, you have to include a final comma

```py
>>> t = 'a',
>>> t
('a',)
```

A single value in parentheses is not a tuple

```py
>>> t = ('a')
>>> t
'a'
```

#### Index Operator

If the argument is a sequence (string, list, or tuple), the result is a tuple with the elements of the sequence

```py
>>> t = ('l','o','g','i','c')
>>> print(t)
('l', 'o', 'g', 'i', 'c')
```

Most list operators also work on tuples

```py
>>> print(t[0])
l
```
#### Slice Operator

Slicing

If you try to modify one of the elements of the tuple

Tuples are immutable

```py
>>> print(t[0])
l
>>> t[0] = 'a'

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [50], in <module>
----> 1 t[0] = 'a'

TypeError: 'tuple' object does not support item assignment
```

#### Assignment

If we want to swap two variables we will need a third variable, for example

```py
>>> a = 25
>>> b = 45
>>> temp = a
>>> a = b
>>> b = temp
>>> print(a)
>>> print(b)
45
23
```

With tuples it is more elegant

```py
>>> print(a,b)
>>> a,b = b,a
>>> print(a,b)
45 25
25 45
```

The right side can be any kind of sequence (string, list, or tuple)

```py
email = 'nayeem@cd.umd.edu'
uname,domain = email.split('@')
print("name:",uname,", domain: ", domain)

output:
name: nayeem , domain: cd.umd.edu
```

#### Tuples as Return Values

```py
quot, rem = divmod(9,4)
print(quot)
print(rem)

output:
2
1
```

#### Variable-Length Argument Tuples

Functions can take a variable number of arguments

A parameter name that begins with a * gathers arguments into a tuple, for example

```py
def printall(*args):
  print(*args)
printall(1,'3.5',"test")

output:
(1, '3.5', 'test')
```

#### Variable Length Arguments

Many of the built-in functions use variable-length argument tuples

For example, max() and min() can take any number of arguments:

```py
>>> max(3,4,7)
7

>>> min(1,3,6)
1
```

sum cannot

```py
>>> sum(1,3,6)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [54], in <module>
----> 1 sum(1,3,6)

TypeError: sum() takes at most 2 arguments (3 given)
```

#### Variable Length Tuples

Write a function called sumall() that takes any number of arguments and returns their sum

```py
def sumall(*args):
  s = 0
  for i in args:
    s += i
  return(s)
print(sumall(2,3,4,5))

output:
14
```

#### Tuple Operations

• Indexing e.g., T[i]

• Slicing e.g., T[1:5]

• Concatenation e.g., T + T

• Repetition e.g., T * 5

• Membership test e.g., ‘a’ in T

• Length e.g., len(T)

### Lambda Functions

#### Anonymous (Lambda) Functions

• An anonymous function is a function that is defined without a name

• While normal functions are defined using the def keyword, anonymous functions are defined using the lambda keyword

• Anonymous functions are typically small, and are used to parameterize an expression

• They are typically created near where they are used

• They can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions

• They are used in combination with the functions filter(), map(), and reduce()

#### Lambda Function Syntax

• Syntax

  • lambda \<argumentlist>: \<expression>

• Argument list consists of a comma separated list of arguments

• Expression is an arithmetic expression using these arguments

```py
>>> p = lambda x,y: x*y
>>> p(3,4)
12
```

```py
def m(x,y):
  return(x*y)
m(3,4)

output：
12
```

#### Why Use Lambda Functions?

The power of a lambda function is evident when it is used (as an anonymous function) inside another function

```py
def findlarger():
  value =  lambda x,y: "x is larger" if x >y else "y is larger"
  return(value)

outpuut = findlarger()
print(type(output))
print(output(3,5))

output:
<class 'function'>
y is larger
```

```py
def myfunc(n):
  return lambda a: a*n

mydoubler = myfunc(2) #n=2
print(mydoubler(11)) #a=11

output:
22
```

#### Functions as parameters

Have you ever wanted to pass an entire function as a parameter

Python has functions as first-class citizens, so you can do this

You simply pass the functions by name

#### Higher-Order Functions

A higher-order function is a function that takes another unction as a parameter

They are “higher-order” because it’s a function of a function

Examples

– Map

– Reduce

– Filter

Lambda works great as a parameter to higher-order functions if you can deal with its limitations

#### map Function

`map()` is a function with two arguments

`r = map(func, seq)`

the first argument func is the name of a function

the second is a sequence (e.g., a list) seq

#### map Function without lambda

```py
def celsius(T):
  return((5/9)*(T-32.))
def fahrenheit(T):
  return((9/5)*T + 32)

temperatures = (-10, -20, -30, 30, 40)
F = map(fahrenheit,temperatures)
temp_in_fahrenheit = list(F)
print("Temperature in Fahrenheit: ", temp_in_fahrenheit)

output:
Temperature in Fahrenheit:  [14.0, -4.0, -22.0, 86.0, 104.0]
```

```py
C = map(celsius, temp_in_fahrenheit)
temp_in_celsius = list(C)
print(temp_in_celsius)

output:
[-10.0, -20.0, -30.0, 30.0, 40.0]
```

#### map Function with lambda

```py
C = [-10, -20, -30, 30, 40]
F = list(map(lambda x: ((9/5)*x + 32), C))
print("Fahrenheit temp: ", F)
C = list(map(lambda x:((5/9) * (x - 32)), F))
print("Celsius: ", C)

output:
Fahrenheit temp:  [14.0, -4.0, -22.0, 86.0, 104.0]
Celsius:  [-10.0, -20.0, -30.0, 30.0, 40.0]
```

#### map() with Multiple Lists

• map() can be applied to more than one list

• The lists have to have the same length

• map() will apply its lambda function to the elements of the argument lists

• It first applies to the elements of the 0th index, then to the elements with the 1st index, so on


```py
a = [1,2,3,4]
b = [17,12,11,10]
c = [-1,-4,5,9]
sumAB = list(map(lambda x,y: x+y,a,b))
print("sumAB: ", sumAB)

sumABC = list(map(lambda x,y,z:x+y+z,a,b,c))
print("sumABC: ", sumABC)

expABC = list(map(lambda x,y,z:2.5*x+2*y-z,a,b,c))
print("expABC: ", expABC)

output:
sumAB:  [18, 14, 14, 14]
sumABC:  [17, 10, 19, 23]
expABC:  [37.5, 33.0, 24.5, 21.0]
```

#### Filtering

• filter function filters out all the elements of a list, for which function returns True

  - `filter(<function>, list)`

• function, f, is the first argument.

• f returns a Boolean value, i.e. either True or False

• This function will be applied to every element of the list

• Only if f returns True will the element of the list be included in the result list

```py
data = [1,3,4,8,5,26]
odd_numbers = list(filter(lambda x : x%2, data))
even_numbers = list(filter(lambda x: x%2==0, data))
print(odd_numbers) # prints [1, 3, 5]
print(even_numbers) # prints [4, 8, 26]
```

#### reduce

• Function reduce continually applies function to the sequence reduce (func, seq)

• If seq = [s1,s2,s3,...,sn], calling reduce(func, seq) works like this

- At first, func will be applied to s1 and s2

- In the next step, func will be applied to the result of step 1 result and s3, and so on


```py
from functools import reduce

data1 = [34,43,56,76]
m = reduce(lambda x,y:x+y, data1)
print(m) # prints sum of list elements (209)

sum = reduce(lambda x,y: x+y, range(1,101))
print(sum) #5050

largest = reduce(lambda x,y : x if x > y else y, [3,25,23,12,4,9])
print(largest) #25

```

#### array

• Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained

•  The type is specified at object creation time by using a type code, which is a single character.

```py
from array import array

a = array('f',[2,4,6,8])
print(a) #array('f', [2.0, 4.0, 6.0, 8.0])

array('f', [2.0, 4.0, 6.0, 8.0]) #array('f', [2.0, 4.0, 6.0, 8.0])

help(array)
```

### Zip

• zip is a built-in function that takes two or more sequences (lists, sets, etc.), and

• “zips” them into a list of tuples, where each tuple contains one element from each sequence

• Returns a zip object

#### Lists and Tuples

The result is a list of tuples, where each tuple contains a character from the string and the corresponding element from the list

```py
s = 'abc'
t = [0,1,2]
zip(s,t)

output:
<zip at 0x1c9de3ba080> # Need to use tuple() or list() to print
```

#### Hashing from Two Arrays

```py
keys = ['x','y','z']
values = [24,25,26]

d = zip(keys,values)
list(d) #[('x', 24), ('y', 25), ('z', 26)]

d1 = list(d)
list(d1)
d1[0] #('x', 24)
```

```py
s1 = {1,3,2}
s2 = {'c','b','a'}
s3 = list(zip(s1,s2))
s3 #[(1, 'a'), (2, 'b'), (3, 'c')]
S1_new, s2_new = zip(*s3)
S1_new #(1, 2, 3)
s2_new #('a', 'b', 'c')
```

#### Hashing from More than 2 Arrays

```py
l1 = [1,2,3,4]
l2 = ['a','b','c','d']
l3 = [2.0,3.0,4.0,5.0]

l4 = zip(l1,l2,l3)
l = list(l4)
l #[(1, 'a', 2.0), (2, 'b', 3.0), (3, 'c', 4.0), (4, 'd', 5.0)]
```

Unzip a list of tuples

```py
x,y,z = zip(*l)
print(x) #(1, 2, 3, 4)
print(y) #('a', 'b', 'c', 'd')
print(z) #(2.0, 3.0, 4.0, 5.0)
```

#### Hashing from Diff. Sized Arrays

```py
list(zip(range(5),range(50))) #[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
```

```py
from itertools import zip_longest

a = [1,2,3]
b = ['x','y','z']
c = range(5)

d = zip_longest(a,b,c,fillvalue='*')
list(d) #[(1, 'x', 0), (2, 'y', 1), (3, 'z', 2), ('*', '*', 3), ('*', '*', 4)]
```

#### Sorting in Parallel



```py
a = [1,3,2]
b = ['c','b','a']

c = list(zip(a,b))
print(c) #[(1, 'c'), (3, 'b'), (2, 'a')]
c.sort()
print(c) #[(1, 'c'), (2, 'a'), (3, 'b')]

d = list(zip(b,a))
print(d) #[('c', 1), ('b', 3), ('a', 2)]
d.sort()
print(d) #[('a', 2), ('b', 3), ('c', 1)]
```

### Dictionaries

An unordered set of key: value pairs

• A mapping between keys and values

• Like an array indexed by a string

• Values of any type; keys of almost any type

• curly brackets

`{"name":"Guido", "age":43, ("hello","world"):1, 42:"yes", "flag": ["red","white","blue"]}`

```py
d = {"foo" : 1, "bar" : 2}
print (d["bar"])       #2

dict1 = {}
dict1["foo"] = "yow!"
print (dict1.keys())   #dict_keys([‘foo’])
```

#### Dictionary Details

Keys are immutable

• numbers, strings, tuples of immutables, these cannot be changed after creation

• reason is hashing (fast lookup technique)

• **not** lists or other dictionaries, these types of objects can be changed "in place"

• no restrictions on values

Keys will be listed in arbitrary order

• again, because of hashing

#### Dictionary vs. List

• A dictionary is like a list

• In a list, the indices must be integers

• In a dictionary they can be almost any type

• And a dictionary is a mapping between keys and values

#### Methods in Dictionary

• keys()

• values()

• items()

• has_key(key)

• clear()

• copy()

• get(key[,x])

• setdefault(key[,x])

• update(D)

• popitem()

#### Initialization

The ‘in’ operator works on the keys in a dictionary

• ‘one’ in en2Ks

```py
en2Ks = dict() # Either one will create an empty dictionary
en2Ks = {}

en2Ks = {'one':'akh','two':'ze','three':'tre'}
'one' in en2Ks #True
```

#### Using zip()to form a Dictionary

Form a dictionary from a keys list and a values list using zip

```py
keys = ['x','y','z']
values = [24,25,26]
d = {k:v for k,v in zip(keys,values)}
d #{'x': 24, 'y': 25, 'z': 26}
```

#### Dictionary Comprehension

Like list comprehension, we can create dictionaries using simple expressions

A dictionary comprehension takes the form '{key: value for (key, value) in iterable}'

E.g.: Convert the values to floating point values

```py
weight = {'a':35,'b':100,'c':175}
float_weight = {key:float(value) for key,value in weight.items()}
float_weight #{'a': 35.0, 'b': 100.0, 'c': 175.0}
```

#### Dictionary Comprehension: Alphabet

Create a list of the alphabet

```py
import string

alphabet = list(string.ascii_lowercase)
print(alphabet,) #['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
```

Create a dictionary with keys as the letters and the values as their position in the alphabet


```py
print({alphabet[i-1]:i for i in range(1,len(alphabet)+1)})
#{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26}
```

#### Values

To see whether a value exists, use a method called values()

```py
'ze' in en2Ks.values() #True
```

#### ‘in’ Operator Algorithms

‘in’ operator uses different algorithms for lists and dictionaries

For lists, it uses a search algorithm

For dictionaries, it uses a hashtable

In a hashtable, the ‘in’ operator takes about the same time no matter how many items there are in a dictionary

#### Looping and Dictionaries

You can use a ‘for’ loop to traverse the keys of a dictionary

Dictionaries have a method called keys that returns the keys of the dictionary, in no particular order, as a list

```py
for key in en2Ks:
  print(key,en2Ks[key])

output:
one akh
two ze
three tre
```

#### Reverse LookUp

Given a dictionary ‘d’ and a key ‘k’

We can find the value using

   v = d[k]

   This is called lookup

If you have v and you want to find k, you have two problems

• there might be more than one key that maps to the value v

• there is no method for reverse lookup, you have to search for it

#### Dictionaries and Lists

Lists can appear as values in a dictionary

Consider a dictionary that maps frequencies to letters

A frequency may be mapped to several letters

• In order to represent such a mapping, the values (letters)
should be a list of letters

lists cannot be keys
```py
t = [1,2,3]
d = dict()
d[t] = 'oops'
```

#### Data Type Wrap Up

• Integers: 2323, 3234

• Floating Point: 32.3, 3.1E2

• Complex: 3 + 2j, 1j

• Lists: l =  [1,2,3]

• Tuples: t = (1,2,3)

• Dictionaries: d = {‘hello’ : ‘there’, 2 : 15}

• Lists, Tuples, and Dictionaries can store any type (including other lists, tuples, and dictionaries!)

• Only lists and dictionaries are mutable

• All variables are references

### Files

#### Introduction

Most of the programs written so far run for a short
duration. Once the program ends, the data is gone. If we want to see the results again, we have to run the
program again

#### Persistence

Some programs run for a long time. They store data permanently. The data is available even after the program ends

For example, operating systems and web servers. One way to read and write data is using files. Another way to store data is using a database

#### Reading a File

Using a built-in function ‘open’

It takes the name of a file and returns a file object

```py
fin = open('../Lectures/words.txt')
fin
```

#### readline()

It can read one line

```py
fin = open('words.txt')
fin.readline() #'MSML 605\n'
```

readlines() reads lines into a list

```py
fin.readlines()
['Course\n','Spring 2020']
```

#### Removing End of Line Character

remove end line character

```py
fin = open('words.txt')
fin.readline().strip('\n') # 'MSML 605'
```

#### File Traversal

```py
fin = open('words.txt')

for line in fin:
  print(line)

output:
MSML 605
Course
Spring 2020
```

#### Writing

To write to a file, you have to open it with mode ‘w’ as a second parameter

If the file already exists, opening it in write mode clears out the old data and starts fresh

```py
fout = open("output.txt", 'w')
```

#### Write to a File

```py
Line1 = "This is a ML class\n"
fout.write(line1)

Line2 = "We Program in Python language\n"
fout.write(line2)
fout.close()
```

#### Format Operator

The argument of write has to be a string. If we want to put other values in a file, we have to convert
them to strings

An alternative is to use the format operator, %

```py
f = open('output.txt', 'w')
x = 53
f.write(str(x))
```

#### Format Sequence

For example, the format sequence ‘%d’ means that the second operand should be formatted as an integer

```py
camels = 42
'%d' % camels #'42'
```

```py
print ('%s is %d years old' % ('Joe', 42)) #Joe is 42 years old
```

#### More Formatting

 A format sequence can appear anywhere in the string

 So you can embed a value in a sentence

```py
camels = 42
'I have spotted %d camels.' % camels ##'I have spotted 42 camels.'
```
 For more than one format sequence in a string, the second argument is a tuple

 Each format sequence with an element of the tuple, in order

 Format Sequences used to format

‘%d’ an integer

‘%g’ a floating-point number

‘%s’ a string


```py
'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
#'In 3 years I have spotted 0.1 camels.'
```

#### Sequence Formatting Rules

 The number of elements in the tuple has to match the number of format sequences in the string

 Also, the types of the elements have to match the format sequences

```py
'%d %d %d' % (1,2)
---------------------------------------------------------------------------
TypeError            Traceback (most recent call last)
Input In [29], in <module>
----> 1 '%d %d %d' % (1,2)

TypeError: not enough arguments for format string
```

```py
'%d' % 'dollars'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [30], in <module>
----> 1 '%d' % 'dollars'

TypeError: %d format: a real number is required, not str
```

#### Filenames and Paths

 import os: os module provides functions for working with files and directories

```py
>>> import os
>>> cwd = os.getcwd()
>>> print(cwd)
/users/george
```

 To find the absolute path to a file, you can use os.path.abspath

```py
>>> os.path.abspath('words')
'/users/george/words'
```

 os.path.exists checks whether a file or directory exists

```py
>>> os.path.exists('words.txt')
False
```
 os.path.isdir checks whether it’s a directory

```py
>>> os.path.isdir('Documents')
True
```
 os.path.isfile checks whether it’s a file

```py
>>> os.path.isfile('test')
True
```

 os.listdir returns a list of the files ( and other directories) in the given directory

```py
>>> os.listdir('/users')
['.localized', 'Guest', 'george', 'Shared']
```

Walk through a directory

```py
import os
def walk(dirname):
  for name in os.listdir(dirname):
    path = os.path.join(dirname,name)
    if os.path.isfile(path):
      print(path)
    else:
      walk(path)
```

```py
train_img_names = [os.path.join(training_path,f) for f in os.listdir(training_path) if
f.endswith('.jpg')]
```

#### Catching Exceptions

 If you try to open a file that doesn’t exist, it will throw an error:

```py
fin = open('our_file')
FileNotFoundError: [Errno 2] No such file or directory: 'our_file'
```

 If you don’t have permission to access a file:

```py
fout = open('/etc/passwd','w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
```

 If you try to open a directory for reading, you get:

```py
fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
```

#### try and except

 There is an option using 'try' and 'except' so that the program does not halt when there is an error

```py
try:
  fin = open('bad_file')
  for line in fin:
    print(line)
  fin.close()
except:
  print('Something went wrong')
```

 Python starts by executing the try clause

 If all goes well, it skips the except clause and proceeds

 If an exception occurs, it jumps out of the try clause

#### Pickling

 A pickle module is used to store Python objects in a database

```py
import pickle
t = [1,2,3]
s = pickle.dump(t, open(“temp”, ”wb”))
t2 = pickle.load(open(“temp”, “rb”))
print(t2) # prints [1, 2, 3]
```

 Although the new object has the same value as the old, it is not the same object

```py
print (t == t2)  # True
print (t is t2)  # False
```

```py
>>> import pickle
>>> dic = {"k1":"v1","k2":123}
>>> s = pickle.dumps(dic)
>>> type(s)
<class 'bytes'>
>>> s
b'\x80\x03}q\x00(X\x02\x00\x00\x00k1q\x01X\x02\x00\x00\x00v1q\x02X\x02\x00\x00\x00k2q\x03K{u.'
>>> dic2 = pickle.loads(s)
>>> dic2
{'k1': 'v1', 'k2': 123}
>>> type(dic2)
<class 'dict'>
```

## Chapter 4 Objects

#### Outline

Objects, classes, instances, and object-oriented programming

 Relationship between classes and instances

 Abstraction

Anatomy of a class

 Instance variables

 Instance methods

 Constructors

#### Object-Oriented Basics

Object: A single software unit that combines attributes and methods

 Attribute: A "characteristic" of an object; like a variable associated with a kind of object

 Method: A "behavior" of an object; like a function associated with a kind of object

Class: Code that defines the attributes and methods of a kind
of object (A class is a blueprint of an object)

 Classes we have seen so far: str, list, dict, etc.

OOP (Object-oriented programming) allows

 representation of real-life objects as software objects (e.g., a dictionary as an object)

 writing programs that perform most of their behavior as interactions between objects

#### Fundamental Concepts of OOP

Information hiding

Abstraction

Encapsulation

 hiding design details to make the program clearer and more easily modified later

Modularity

 the ability to make objects stand alone so they can be reused

Polymorphism

 Allow one message to be sent to any object and have it respond appropriately based on the type of object it is

Inheritance

 create a new object by inheriting (like father to son) many object characteristics while creating or over-riding for this object

#### Abstraction

Distancing between ideas and details

Objects in Python provide abstraction: We can use them without knowing how they work

You use abstraction every day

Example: smart phone

We understand its external behavior (home button, screen, etc.)  

We don't understand its inner details (and don't need to)

#### Encapsulation

Hiding implementation details of an object from clients

Encapsulation provides abstraction: we can use objects without knowing how they work

The object has:

 an external view (its behavior)

 an internal view (the state and methods that  accomplish the behavior)

#### Class versus Instance

 The analogy of the cookie cutter and cookie

 The cutter is a template for stamping out cookies; the cookie is what is made each time the cutter is used

 One template can be used to make an infinite number of cookies, each one having the same shape as the other

 No one confuses a cookie for a cookie cutter, do they?

#### Class versus Instance

 You define a class as a blueprint to generate new instances of that class

 Instances are objects that are created based on the definition given
inside the class

 Both the class and the instances are themselves objects

 The structure of each instance starts out  the same, as dictated by the class

 The instances respond to the methods defined as part of the class

#### Class versus Instance
```py
Music player blueprint:

State:
current song
volume
battery life  

Behavior:  
power on/off
change station/song
change volume
choose random song
```

```py
Music player #1

state:
song = "Let it snow"  
volume = 17
battery life = 2.5 hrs

behavior:
power on/off
change station/song  
change volume  
choose random song
```

```py
Music player #2

state:
song = "Galaxy song"  
volume = 9
battery life = 3.41 hrs

behavior:
power on/off  
change station/song  
change volume  
choose random song
```

```py
Music player #3
state:
song = "Code Monkey"  
volume = 24
battery life = 1.8 hrs

behavior:
power on/off
change station/song  
change volume  
choose random song
```

### Defining Classes in Python

#### In Pythion, it’s all Objects...

In case you haven’t noticed, everything in Python is really an object

 We’ve seen hints of this already through built-in classes and their methods ...
```py
"hello".upper()
list3.append('a')
dict2.keys()
```

 These look like Java or C++ method calls

 We can define new object classes in addition to these built-in data-types

In fact, programming in Python is typically done in an object-oriented fashion

#### Data Type vs Class

There is a strong similarity between Python data types and Python classes

Data types

 Seen many data types already: list, dict, str, ...

 Suitable for representing different data

 Respond to different methods regarding the manipulation of that data

 Classes are more complicated, user-defined data types

#### Standard Class Names

The standard way to name a class in Python is called CapWords

 Each word of a class begins with a Capital letter

 No underlines

 Sometimes called CamelCase

 Makes it easier to recognize a class

#### Defining a Class

Python doesn’t use separate class interface definitions as in some languages

You just define the class and then use it

Declaring a class
```py
class Name:
  statements
```

Example
```py
class Point:    
  x = 0
```

The class definition is terminated by a blank line

#### Variables and Methods

The class description may define:

  a set of variables (attributes)

 A set of methods

Variables are for storing data

Methods are for specifying behavior

#### Class Variables (Attributes)

Owned by the class as a whole  

 All class instances have access to the class variable

 They share the same value for it

 If one instance changes the value, all instances see the change

Called “static” variables in some languages  

Stored in pre-defined class variable ClassName.__dict__

Good for

 class-wide constants

 building counter of how many instances of the class have been made

#### Declaring a Class Attribute

A class attribute can be declared and initialized

 Inside class, but outside of any method

 In constructor methods

 Outside class

```py
class Point:
  x = 0 # inside class
  def __init__(self):
    self.__class__.y = 1 # in constructor

Point.z = 2 # Outside class
```

#### Referencing a Class Variable

Class variable references use standard syntax. E.g.,


```py
class Point:
"""A simple example class"""
    x = 2
    def f(self):
      return 'hello world'
```

◦ Point.x would return an integer, and Point.f would return an object

◦ Class attributes, like Point.x, can have their values changed by assignment

◦ \_\_doc\_\_ is also a valid attribute and will return the docstring belonging to the class. i.e., “A simple example class”

### Instantiation

#### Instantiation

When Python encounters a class definition, it automatically creates a function with the same name as the class

 This function is called a constructor

By calling the constructor function (with no parameters), you can create an instance of the class

 Creates an empty object

 Good to assign the result to a variable (name of created instance)

 Instance inherits a personal set of variables (same names as the class variables)

```py
class Point:
   x = 0
   y = 0

# main
p1 = Point()         # p1 is an object of class Point
p1.x = 2
p1.y = -5
```

#### Instantiation Using \_\_new\_\_

Another way to create an instance of a class is to use the class' built-in method \_\_new\_\_

The first argument when calling \_\_new\_\_ is the class name

```py
class Point:
  x = 0
  y = 0

p1 = Point.__new__(Point)
p1.x = 2
P1.y = 3
```

#### Instance Variables & Behavior

Like classes, instances also have state and behavior  

Instance variables: define state of the instance

Instance methods: define behavior for each object of a class. Methods are the way objects communicate with each other and with users

#### Instance Variables

Instance inherits a personal set of variables (same names as the class variables) from its class at time of creation

Stored in pre-defined instance variable instanceName.\_\_dict\_\_

The first argument when calling \_\_new\_\_ is the class name

```py
class Point:
  x = 0
  y = 0

p1 = Point()
p1.x = 2        # different from Point.x
p1.y = 3
p1.z = 4        # z is instance variable only
```

#### Referencing an Instance Variable

Instance variable references also use standard syntax. E.g.,

```py
class Point:
  """A simple example class"""
  x = 0
  y = 0

p1 = Point()
p1.x = 2
Point.x # prints 0
```

◦ p1.x refers to instance variable x

◦ Point.x refers to class variable x

#### Instance Knows its Class

Because an instance has as its type the class that it was made from, each instance remembers its class

This is often called the instance-of Relationship

Stored in the instanceName.\_\_class\_\_ attribute

#### Review: Two Kinds of Attributes

The non-method data stored by objects are called attributes  

Instance attributes

 Owned by a particular instance of a class

 Each instance has its own value for it

 These are the most common kind of attribute

Class attributes

 Owned by the class as a whole  

 All class instances share the same value for it

 Called “static” variables in some languages  

Good for:

 class-wide constants

 keeping count of how many instances of the class have been made

#### Instance vs. Class Attributes

```py
class counter:
overall_total = 0
     # class attribute
def __init__(self):
    self.my_total = 0
      # data attribute
def increment(self):
   counter.overall_total = \
   counter.overall_total + 1
   self.my_total = \
   self.my_total + 1
```

```py
>>> a = counter()
>>> b = counter()
>>> a.increment()
>>> b.increment()
>>> b.increment()
>>> a.my_total
1
>>> a.__class__.overall_total
3
>>> b.my_total
2
>>> b.__class__.overall_total
3
```

#### Importing a Class

`import class`

Client programs must import the classes they use

```py
from Point import *

class Point:
  x = 0
  y = 0

# main
p1 = Point()
p1.x = 7
p1.y = -3

# Python objects are dynamic (can add fields any time!)
p1.name = "John Smith"
```

```py
class MyClass(object):
  pass

my_instance = MyClass()
MyClass.class_attribute = 'hello'
my_instance.instance_attribute = 'world'

dir(my_instance)
#[‘__class__’, ... , ‘class_attribute’, ‘instance_attribute’]


print(my_instance.__class__)
# <class ‘__main__.MyClass’>

type(my_instance)
# <class ‘__main__.Myclass’>

print(my_instance.instance_attribute)
# world

print(my_instance.class_attribute)
#hello

Pring(MyClass.instance_attribute)

---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
Input In [20], in <cell line: 1>()
----> 1 Pring(MyClass.instance_attribute)

NameError: name 'Pring' is not defined
```

#### Deleting Instance: No Need to free

When you are done with an object, you don’t have to delete or free it explicitly

Python has automatic garbage collection

Python will automatically detect when all of the references to a piece of memory have gone out of scope. Automatically frees that memory

Generally works well, few memory leaks

There’s also no “destructor” method for classes

### Object Behavior: Methods

#### Method versus Function

Method and function are closely related. They are both “small programs” that have parameters, perform some operation and (potentially) return a value

Main difference is that methods are functions tied to a particular object

Functions are called, methods are called in the context of an object

function:

`do_something(param1)`

method:

`an_object.do_something(param1)`

This means that the object that the method is called on is always implicitly a parameter!

#### Methods in a Class

We can define a method inside a class by including function definitions within the scope of the class block

Beware – data attributes override method attributes with the same name!

The first argument of every method is a reference to the current instance of the class

By convention, we name this argument `self`


```py
def name(self, parameter, …, parameter):
  statements

class Point:
  def translate(self, dx, dy):
    self.x += dx
    self.y += dy
    ...
```

#### Implicit Parameter (self)

`self` is a reference to the current instance. `self` lets you access all the instance variables for the specific instance you’re working with

Java: this, implicit
```Java
public void translate(int dx, int dy) {
  x += dx; // this.x += dx;
  y += dy; // this.y += dy;
}
```

Python: self, explicit

```py
def translate(self, dx, dy):
  self.x += dx
  self.y += dy
```

#### Exercise

Write methods `for distance, set_location`, and `distance_from_origin`

```py
from math import *

class Point:
  x = 0
  y = 0
  def set_location(self, x, y):
    self.x = x
    self.y = y
  def distance_from_origin(self):
    return sqrt(self.x * self.x + self.y * self.y)
  def distance(self, other):
    dx = self.x - other.x
    dy = self.y - other.y
    return sqrt(dx * dx + dy * dy)
```

#### Calling a Method of an Object

A client can call a method of an object using the dot notation in one of 2 ways

The value of self can be an implicit or explicit parameter

1) object.method(parameters)

 or

2) Class.method(object, parameters)

```py
#Examples:
p = Point(2, 3)
p.translate(1, 5)
Point.translate(p, 1, 5)
```

Class & Object: Another Example

```py
class test():
  """ Example class"""
  x = 14
  def t(self):
    return('test class')

r = test()
print(r.x)
a = r.t()
print(a)

----------
14
test class
```

### Special Built-In Methods and Attributes

####

```py

```


####

```py

```

####

```py

```


#### 

```py

```

####

```py

```

####

```py

```


####

```py

```

####

```py

```

####

```py

```


####

```py

```

####

```py

```

####

```py

```


####

```py

```

####

```py

```

####

```py

```


####

```py

```

####

```py

```

####

```py

```


####

```py

```
