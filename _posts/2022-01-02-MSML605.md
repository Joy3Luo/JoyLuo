---
layout: post
title: Computing Systems for Machine Learning
date: 2022-01-02 12:18 +0800
tags: [python]
toc:  true
math: true
---

<!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TG0XJZG53F"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-TG0XJZG53F');
  </script>

  <style TYPE="text/css">code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}</style><script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
      }});
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i = 0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }});
  </script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>  

## Chapter 1 Introduction

skipped :3

## Chapter 2 Python Fundamentals

### Syntax

#### hello. py

Python does not have a main method like Java

-The program's main code is just written directly in the file

Python statements do not end with semicolons

```py
print("Hello, world!")
```

#### Multi-Line Statements

Statements in Python typically end with a new line. Python does, however, allow the use of the line continuation character (\\) to denote that the line should continue. For example:

```py
total = item_one + \
        item_two + \
        item_three
```
Statements contained within the [], {}, or () brackets do not need to use the line continuation character. For example:

```py
days = ['Monday', 'Tuesday', 'Wednesday',
                'Thursday', 'Friday']
```

#### Quotation in Python

Python accepts single ('), double (") and triple (''' or """) quotes to denote string literals, as long as the same type of quote starts and ends the string

The triple quotes can be used to span the string across multiple lines. For example, all the following are legal:

```py
word = 'word'
sentence = "This is a sentence."
paragraph = """This is a paragraph. It is made up
  of multiple lines and sentences."""
```

#### Comments

As programs get bigger and more complicated, they become more difficult to read

It is a good idea to add notes to your programs

A # symbol that is not inside a string starts a comment

All characters after the # and up to the physical line end are part of the comment

Python interpreter ignores them


#### Using Blank Lines

A line containing only whitespace, possibly with a comment, is known as a blank line, and is ignored by the Python interpreter

In an interactive interpreter session, you must enter an empty physical line to terminate a multiline statement


#### Multiple Statements on a Single Line

The semicolon ( ; ) allows multiple statements on the single line given that neither statement starts a new code block. Here is a sample snip using the semicolon:

```py
import sys; x = 'foo'
```

#### Multiple Statement Groups as Suites

Groups of individual statements making up a single code block are called `suites` in Python

Compound or complex statements, such as `if`, `while`, `def`, and `class`, are those which require a header line and a suite

Header lines begin the statement (with the keyword) and terminate with a colon ( : ) and are followed by one or more lines which make up the suite

```py
if expression1 :
  suite1
elif expression2 :
  suite2
else :
  suite3
```

#### Suites and Indentation

One of the first caveats programmers encounter when learning Python is that there are no braces to indicate blocks of code for class and function definitions or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced

The number of spaces in the indentation is variable, but all statements within the block must be indented the same amount

```py
if x == True:
  print ("Answer")
  print ("True")
else:
  print ("Answer")
  print ("False")
```

#### Reserved Words

Keywords contain lowercase letters only
```
and exec not assert finally or break for
class from print continue global raise def
return del import try elif in while else is
except lambda yield pass if with
```

### Variables and Expressions

#### Variable Name

Variable names can be both letters and numbers

They have to begin with a letter though

Uppercase letters are allowed, generally we use lowercase

Underscore character (_) can also appear in a name

Variable name cannot be a keyword

An illegal name results in a syntax error


#### Assigning Values to Variables

Python variables do not have to be explicitly declared to reserve memory space

The declaration happens automatically when you assign a value to a variable. The equal sign (=) is used to assign values to variables

```py
>>> counter = 100  # An int assignment
>>> miles = 1000.0 # A float
>>> name = "John"  # A str
>>> print (counter)
>>> print (miles)
>>> rint (name)
100
1000.0
John
```

#### Constants

Python doesn't really have `constants`

Instead, declare a "global" variable at the top of your code

All methods will be able to use this value

```py
MAX_VALUE = 3
```

#### Multiple Assignments

You can also assign a single value to several variables simultaneously

```py
a = b = c = 1
a, b, c = 1, 2, "john"
```

#### Data Types

Number types: int, float, complex

Sequence type:, str (immutable), list, tuple (immutable), range, zip (sequence of tuples)

Boolean type: bool

Set type: set, frozenset

Mapping type: dict

Binary type: bytes, bytearray, memoryview

#### Data Types: Java vs Python

Python is looser about types than Java

Variables' types do not need to be declared

Variable can change type as a program is running

If the variable value is set to a value of a different type

```py
a = 1       # integer type
a = "john"  # string type
```

Value|Java|Python
:--|:--|:--
42|int|int
3.4|double|float
"hi!"|string|str


#### Expressions and Statements

An expression is a combination of values, variables, and operators

A value or variable all by itself is also an expression

```py
Examples
21
x
x+21
```

A statement is a unit of code that a Python interpreter can execute, for example,

• print

• assignment

#### Operators and Operands

Operators represent computations like addition, multiplication, division, etc.

• \+  -  *  /  %  **

The values the operator is applied to are called operands

```py
>>> 1 + 1
2
>>> 1 + 3 * 4 - 2
11
>>> 7 / 2
3
>>> 7.0 / 2
3.5
>>> 10 ** 6
1000000
```

#### Modulus Operator

Works on integers

Yields the remainder of the first operand divided by the second

Indicated by %

• Quotient = 7 // 3

• Remainder = 7 % 3

Utility: find the last digits of a number

```py
>>> 97856 % 100
56
```

#### Order of Operations

When multiple operators appear in an expression, the order of evaluation depends on the rules of precedence

**PEMDAS**

• Parenthesis: (1+1)\*\*(5-3)
• Exponentiation: 2\*\*1+1


Multiplication and division have the same precedence; addition and subtraction have the same precedence

Operators with the same precedence are evaluated from left to right (except exponentiation which has right-to-left precedence)

```py
>>> 2/5*3
1.2000000000000002

>>> 2**3**2 # = 2**9
512
```

#### Operators: Java vs Python

No ++ or -- operators (must manually adjust by 1)

Java
```Java
int x = 2;
x++;
System.out.println(x);

x = x * 8;
System.out.println(x);

double d = 3.2;
d = d / 2;
System.out.println(d);
```

Python
```py
x = 2
x += 1 # x + 1
print(x) # 3

x = x * 8
print(x) #24

d = 3.2
d = d / 2
print(d) #1.6
```

#### str Data Type

Strings in Python are identified as a contiguous set of characters in between quotation marks

Python allows for either pairs of single or double quotes. Subsets of strings can be taken using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the string and working their way from -1 at the end

The plus ( + ) sign is the string concatenation operator, and the asterisk (*) is the repetition operator

```py
str1 = 'Hello World!'
print str1 # Prints complete string
print str1[0] # Prints first character of the string
print str1[2:5] # Prints characters starting from 3rd to 6th
print str1[2:] # Prints string starting from 3rd character
print str1 * 2 # Prints string two times
print str1 + "TEST" # Prints concatenated string

Output:
Hello World!
H
llo
llo World!
Hello World!Hello World!
Hello World!TEST
```

#### String Operations

You can’t perform mathematical operations on strings

Examples

• ‘2’ - ’1’

• ‘eggs’ / ‘dozens’

The + operator works with strings and performs concatenations

```py
first = 'hello'
second = 'class'
print(first + second) #helloclass
```

#### String Multiplication

The * operator works with strings and performs repetition

```py
>>> 'Spam'*3
'SpamSpamSpam'
```


If one of the operands is a string, the other has to be an integer

```py
>>> "hello" * 3
"hellohellohello"

>>> print(10 * "yo ")
yo yo yo yo yo yo yo yo yo yo

>>> print(2 * 3 * "4")
444444
```

#### String Concatenation

Integers and strings cannot be concatenated in Python

str(value) - converts a value into a string

print(expr, expr)  - prints two items on the same line

```py
>>> x = 4
>>> print("Thou shalt not count to " + x + ".")
TypeError: cannot concatenate 'str' and 'int' objects

>>> print("Thou shalt not count to " + str(x) + ".")
Thou shalt not count to 4.

>>> print(x + 1, "is out of the question.")
5 is out of the question.
```

#### list Data Type

Lists are the most versatile of Python's compound data types. A list contains items separated by commas and enclosed within square brackets ([])

To some extent, lists are similar to arrays in C. One difference between them is that all the items belonging to a list can be of different data type

The values stored in a list can be accessed using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the list and working their way to end-1

The plus ( + ) sign is the list concatenation operator, and the asterisk ( * ) is the repetition operator

```py
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print (list)          # Prints complete list
print (list[0]）       # Prints first element of the list
print (list[1:3)     # Prints elements starting from 2nd till 3rd
print (list[2:])      # Prints elements starting from 3rd element
print (tinylist * 2)  # Prints list two times
print (list + tinylist) # Prints concatenated lists

OUTPUT:
['abcd', 786, 2.23, 'john', 70.2]
abcd
[786, 2.23]
[2.23, 'john', 70.2]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.2, 123, 'john']
```

#### tuple Data Type

A tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parentheses

The main differences between lists and tuples are: Lists are enclosed in brackets ( [ ] ), and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read-only lists

```py
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2  )
tinytuple = (123, 'john')

print(tuple)        # Prints complete list
print(tuple[0])        # Prints first element of the list
print(tuple[1:3])     # Prints elements starting from 2nd till 3rd
print (tuple[2:])       # Prints elements starting from 3rd element
print (tinytuple * 2)   # Prints list two times
print (tuple + tinytuple) # Prints concatenated lists

OUTPUT:
('abcd', 786, 2.23, 'john', 70.2)
abcd
(786, 2.23)
(2.23, 'john', 70.2)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.2, 123, 'john')
```

#### dict Data Type

Python 's dictionaries are hash table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs

Keys can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object

Dictionaries are enclosed by curly braces ( { } ) and values can be assigned and accessed using square braces ( [] )

```py
dict = {}
dict['one'] = "This is one"
dict[2]     = "This is two"
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print(dict['one'])      # Prints value for 'one' key
print (dict[2])          # Prints value for 2 key
print (tinydict)         # Prints complete dictionary
print (tinydict.keys())  # Prints all the keys
print (tinydict.values()) # Prints all the values

OUTPUT:
This is one
This is two
{'dept': 'sales', 'code': 6734, 'name': 'john'}
['dept', 'code', 'name']
['sales', 6734, 'john']
```

#### Data Type Conversion

Function|Description
---|---
int(x [,base])| Converts x to an integer. base specifies the base if x is a string
long(x [,base] ) | Converts x to a long integer. base specifies the base if x is a string
float(x) | Converts x to a floating-point number
complex(real [,imag]) | Creates a complex number
str(x) | Converts object x to a string representation
repr(x) | Converts object x to an expression string
eval(str) | Evaluates a string and returns an object
tuple(s) | Converts s to a tuple
list(s) | Converts s to a list
set(s) | Converts s to a set
dict(d) | Creates a dictionary. d must be a sequence of (key,value) tuples
frozenset(s) | Converts s to a frozen set
chr(x) | Converts an integer to a character
unichr(x) | Converts an integer to a Unicode character
ord(x) | Converts a single character to its integer value
hex(x) | Converts an integer to a hexadecimal string
oct(x) | Converts an integer to an octal string

### Conditionals

#### Boolean Expressions

A boolean expression is an expression that is either true or false

It uses the operator '=\=', which compares the operands to the left and the right of this operator

It produces either True or False

```py
>>> 5==5
True

>>> 5==6
False
```

True and False are of type bool

#### Other Relational Operators

```py
x != y # x is not equal to y

x > y # x is greater than y

x < y # x is less than y

x >= y # x is greater than or equal to y

X <= y # x is less than or equal to y
```

#### Logical Operators

Three logical operators: and, or, and not.

• x > 0 and x < 10 : is true only if x is greater than 0 and less than 10

• n%2 == 0 or  n%3 == 0 : is true if either of the conditions is true, that is, if the number is divisible by 2 or 3

• The not operator negates a boolean expression, so not(x > y) is true if x > y is false, that is, if x is less than or equal to y

#### Conditional Execution

We need to check conditions and change the behavior of the program

The simplest conditional statement is if, for example:

```py
>>> if x>0:
...   print('x is positive')
x is positive
```

The Boolean expression after ‘if’ is called the condition

#### if Statement

if statements have a header followed by an indented body

Statements like these are called compound statements

There is no limit on the number of statements that can appear in the body, but there must be at least one

Sometimes it is useful to have a body with no statements, usually as a place holder

In that case use the pass statement, which does nothing

```py
if x < 0: pass  # need to handle negative values
```

#### Alternative Execution

When there are two possibilities and the condition determines which one gets executed

```py
if x%2 == 0:
  print('x is even')
else:
  print('x is odd')
```

The alternatives are called branches, because they are branches in the flow of execution

#### Chained Conditionals

Sometimes there are more than two possibilities and we need more than two branches

One way to express a computation like that is a chained conditional:

```py
if(x <y):
  print('x is less than y')
elif(x>y):
  print('x is greater than y')
else:
  print('x and y are equal')
```

elif is an abbreviation of "else if"

There is no limit to the number of elif statements

If there is an else clause, it must be at the end

Each condition is checked in order. If the first one is false, the next is checked, and so on

We don’t need an else statement:

```py
if choice == 'a':
  draw_a()
elif choice == 'b':
  draw_b()
elif choice == 'c':
  draw_c()
```

### Functions

#### Function

A function is some reusable code that

• takes arguments(s) as input

• does some computation and

• returns a result or results

There are two kinds of functions in Python

• Built-in functions that are provided as part of Python - raw_input(), type(), float(), int() ...

• Functions that we define ourselves and then use

We treat the built-in function names as "new" reserved words (i.e., we avoid them as variable names)

#### A Built-in Function: max()

A built-in function is some stored code that we use. It takes some input and produces an output.

```py
# If the items in an iterable are strings, the largest item (ordered alphabetically) is returned.
>>> big = max('Hello world')
>>> print (big)
'w'
```

```py
square = {2: 4, -3: 9, -1: 1, -2: 4}

# the largest key
key1 = max(square)
print("The largest key:", key1)    # 2

# the key whose value is the largest
key2 = max(square, key = lambda k: square[k])

print("The key with the largest value:", key2)    # -3

# getting the largest value
print("The largest value:", square[key2])    # 9
```

```py
#Finding largest and smallest key in the dictionary using len()
l1={'carrot':'vegetable','red':'color','apple':'fruit'}
#min() and max() based on len function
print (min(l1,key=len))
#Output:red
print (max(l1,key=len))
#Output:carrot

#Finding largest and smallest values in the dictionary based on len()
print (min(l1.values(),key=len))
#Output:color
print (max(l1.values(),key=len))
#Output:vegetable
```

#### Type Conversion Functions

There are built-in functions in Python that convert from one data type to another

• The int() function takes any value and converts it into an integer, if it can

• int() can convert floating-point values to integers, but it doesn’t round off, and instead chops off the fraction part

• float() converts integers and strings to floating-point numbers

• str() converts its arguments to string

#### Math Functions

Python has a math module that provides mathematical functions

Before using the module, it needs to be imported `import math`

This module contains the functions and variables defined in the module

To access one of the functions, you have to specify the name of the module and the name of the function

#### Import

Python provides 2 ways to import modules

• We have already seen  import math

• import statement imports all the functions from a module into the code

We can also import functions using  from

• Imports only the specified function

• Syntax

```py
from [module] import [function or value]

from random import choice
```

#### Counting and Iterating Functions

len: returns the number of items of an enumerable object

```py
>>> len( [‘c’, ‘m’, ‘s’, ‘c’, 3, 2, 0] )
7
```

range: returns an iterable object

```py
>>> list( range(10) )
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

enumerate: returns iterable tuple (index, element) of a list

```py
>>> enumerate( ["311", "320", "330"] )
[(0, "311"), (1, "320"), (2, "330")]
```

#### Map and Filter Functions

map: apply a function to a sequence or iterable

```py
>>>arr = [1, 2, 3, 4, 5]
>>>map(lambda x: x**2, arr)
[1, 4, 9, 16, 25]
```

```py
>>> map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])
[3, 7, 11, 15, 19]
```
filter: returns a list of elements for which a predicate is true

```py
>>>arr = [1, 2, 3, 4, 5, 6, 7]
>>> filter(lambda x: x % 2 == 0, arr)
[2, 4, 6]
```

#### User-Defined Functions

A named sequence of statements that perform a certain computation

After defining a function, you can call it by name

• Example: type(34)

#### Why Define & Use Functions?

• A group of statements gets a name

• Modular code

• Easier debugging

• Code reuse

#### User-Defined Functions

Function: Equivalent to a static method in Java

Use keyword `def`

Syntax:
```py
def name():
  statement
  statement
  ...
  statement
```

```py
# Prints a helpful message.
def hello():
  print("Hello, world!")

# main (calls hello twice)
hello()
hello()
```
Must be declared above the 'main' code

Statements inside the function must be indented

#### Whitespace Significance

Python uses indentation to indicate blocks, instead of {}

• Makes the code simpler and more readable

• In Java, indenting is optional.  In Python, you must indent

#### Arguments, Parameters, Variables

Most functions require arguments

• E.g.: math functions

An expression can also be used as an argument

Inside the function, arguments are assigned to variables called parameters

• Parameters are local to the function

Some functions return a value and others return nothing (void)

A variable created inside a function is local

#### Example Code

```py
def summation(x,y):
  z = x + y
  return(z)

print(summation(2,4))

m = summation(2,4)
print(m)
```

```py
def decide(x,y):
  if x=='green’ and y=='Red’:  
    print("You can go!")

y = 'Red'
y = 'green'
y = 'green'
z = 'Red'

decide(z,y)
```

### Iterations

#### Iterations

Involves repetition

A statement or group of statements that need to be repeated

Help in automation of repeated tasks

#### The for Loop

```py
for name in range(max):
    statements
```

Uses an iterator (name) and repeats for values 0 (inclusive) to max (exclusive)

```py
>>> for i in range(5):
...     print(i)
0
1
2
3
4
```

#### for Loop Variations

```py
for name in range(min, max):
    statements

for name in range(min, max, step):
    statements
```

Can specify a min other than 0, and a step other than 1

```py
>>> for i in range(2, 6):
...     print(i)
2
3
4
5
>>> for i in range(15, 0, -5):
...     print(i)
15
10
5
```

#### Nested Loops

Nested loops are often replaced by string * and +

```py
for line in range(1, 6):
  print((5 - line) * "." + str(line))

output:
....1
...2
..3
.4
5
```

```py
def bar():
  print "#" + 16 * "=" + "#"
def top():
  for line in range(1, 5):        # split a long line by ending it with \     
    print("|" + (-2 * line + 8) * " " + \
         "<>" + (4 * line - 4) * "." + "<>" + \
         (-2 * line + 8) * " " + "|")
def bottom():    
  for line in range(4, 0, -1):        
    print("|" + (-2 * line + 8) * " " + \
         "<>" + (4 * line - 4) * "." + "<>" + \
         (-2 * line + 8) * " " + "|")

# main
bar()
top()
bottom()
bar()


output:
#================#
|      <><>      |
|    <>....<>    |
|  <>........<>  |
|<>............<>|
|<>............<>|
|  <>........<>  |
|    <>....<>    |
|      <><>      |
#================#
```

```py
def bar():
  print("#" + 16 * "=" + "#")

def mirror():
  for line in range(1, 5) + range(4, 0, -1):
    print("|" + (-2 * line + 8) * " " + \
    "<>" + (4 * line - 4) * "." + "<>" + \
    (-2 * line + 8) * " " + "|")

# main
bar()
mirror()
bar()

output:
#================#
|      <><>      |
|    <>....<>    |
|  <>........<>  |
|<>............<>|
|<>............<>|
|  <>........<>  |
|    <>....<>    |
|      <><>      |
#================#
```

```py
SIZE = 4

def bar():
  print("#" + 4 * SIZE * "=" + "#")

def mirror():
  for line in range(1, SIZE + 1) + range(SIZE, 0, -1):
    print("|" + (-2 * line + 2 * SIZE) * " " + \
    "<>" + (4 * line - 4) * "." + "<>" + \
    (-2 * line + 2 * SIZE) * " " + "|")

# main
bar()
mirror()
bar()

output:
#================#
|      <><>      |
|    <>....<>    |
|  <>........<>  |
|<>............<>|
|<>............<>|
|  <>........<>  |
|    <>....<>    |
|      <><>      |
#================#
```
#### Concatenating Ranges

Ranges can be concatenated with +

• Can be used to loop over a disjoint range of numbers

```py
>>> range(1, 5) + range(10, 15)
[1, 2, 3, 4, 10, 11, 12, 13, 14]

>>> for i in range(4) + range(10, 7, -1):
...     print(i)
0
1
2
3
10
9
8
```

#### while Loop

It requires a condition, e.g.,

```py
n = 12
while(n >0):
  print(n)
  n = n - 1
```

In the definition there is no starting iterator

We need to use a condition with the while

#### Execution Flow for a while Loop

At the start of each iteration, evaluate the condition, yielding True or False

If the condition is false, exit the while statement and continue execution at the next statement

If the condition is true, execute the body and then go to the condition again

The body of the loop will change the value of one or more variables so that condition eventually becomes false and the loop terminates

#### break Statement

Sometimes we want to break out of a loop if some condition is satisfied

```py
n = 12
while(n >0):
  print(n)
  n = n - 1
  if n == 7:
    break

output:
12
11
10
9
8
```

## Chapter 3 Python Advanced

### Strings

#### String

A sequence type

A sequence of zero or more characters

course = "MSML 605"

A string is delimited (begins and ends) by single or double quotes

```py
poem = 'Ode to a Nightingale'
lyric = "Roll on, Columbia, roll on"
exclamation = "That makes me !#? "
```

The empty string has zero characters ('' or "")

**Quote Characters in Strings**

• You can include a single quote in a double quoted string or a double quote in a single quoted string

```py
will = "All the world's a stage"
ben = 'BF: "A penny saved is a penny earned"'
```

• To put a single quote in a single quoted string, precede it with the backslash ('\\') or 'escape' character.  

```py
>>> will = 'All the world\'s a stage'
>>> print(will)
All the world's a stage
```

• The same goes for double quotes

```py
>>> ben = "BF: \"A penny saved is a penny earned\""
>>> print(ben)
BF: "A penny saved is a penny earned"
```

**Putting a Format Character in a String**

• A format character is interpreted by the print() function to change the layout of text

• To put a format character in a string, precede it with the backslash ('\')

• A newline is represented by '\n'  

```py
>>> juliette = 'Good night, good night\nParting is such sweet sorrow'
>>> print(juliette)
Good night, good night
Parting is such sweet sorrow
```

• A tab is represented by '\t'

```py
>>> tabs = 'col0\tcol1\tcol2'
>>> print(tabs)
col0 col1 col2
```

#### Bracket operator and Index

You can access the characters one at a time with the bracket operator

The first character has index 0

`second_character = course[1]`

```py
>>> course = "MSML 605"
>>> second_character = course[1]
>>> print(second_character)
S
```
index has to be an integer

#### Negative Indices

Using negative indices: counts backwards from the string end

```py
>>> course[-1]
5
```

#### len() Function

len() returns the number of characters in a string:

```py
>>> len(course)
8
```

last index using length

#### Traversal with while

Processing one character at a time

```py
course = "MSML 605"
index = 0
while index < len(course):
  letter = course[index]
  print(letter)
  index +=1

output:
M
S
M
L

6
0
5
```

Displays each character on a separate line

#### Traversal with for

A more Pythonic way to traverse a string using for

```py
course = "MSML 605"
for c in course:
  print(c)

output:
M
S
M
L

6
0
5
```

```py
course = "MSML 605"
for c in course:
  print(c, end = ' ')

output:
M S M L   6 0 5
```

#### String Concatenation

Two strings can be concatenated using the ‘+’ operator

```py
word1 = 'abc'
word2 = 'def'
word = word1 + word2
print(word)

output:
abcdef
```

#### String Slices

A segment of a string is a slice

Selecting a slice is similar to selecting a character

```py
>>> greeting = 'hello, world'
>>> greeting[1:3]
'el'
>>> greeting[-3:-1]
'rl'
```

The operator [n:m] returns the part of the string from the "n-eth" character to the "m-eth" character

It includes the first but excludes the last

If the first index before the colon is omitted, the slice starts at the beginning of the string.

If you omit the second index, the slice goes to the end of the string

```py
>>> print(greeting[:4], greeting[7:])
hell world
```

If the first index >= second index, the result is an empty string

You can pick every kth element if you like

```py
>>> greeting[3:10:2]
'l,wr'
```

#### Strings Are Immutable

Once created, a string cannot be modified

What happens if [ ] operators are used on the left side of the assignment operator?

```py
>>> greeting = 'hello, world'
>>> greeting[0] = 'J'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [19], in <cell line: 2>()
      1 greeting = 'hello, world'
----> 2 greeting[0] = 'J'

TypeError: 'str' object does not support item assignment
```

You can create a new string

```py
>>> greeting = 'hello, world'
>>> greeting = 'J' + greeting[1:]
>>> greeting
'Jello, world'
```

It does not change the original string

#### String Search

```py
def find(word,letter):
  index = 0
  while index < len(word):
    if word[index] == letter:
      return(index)
    index +=1
  return(-1)
```

find is the opposite of the [ ] operator

Instead of taking an index and extracting the corresponding character, it takes a character and finds an index

#### Looping and Counting

The following program counts the number of times the letter ‘a’ appears in a string

```py
word = 'banana'
count = 0
for leter in word:
  if letter == 'a':
    count +=1
print(count)

output:
3
```

#### upper() Method

A method is a function that is bundled together with an object: it takes arguments and returns a value

The syntax is different, for example

```py
word = 'banana'
word = word.upper()
word

OUTPUT
'BANANA'
```

A method call is called an invocation

We are invoking upper() on word

#### find() Method

There is a string method named `find()`

```py
word = 'banana'
index = word.find('a')
print (index)  # will print 1, the first instance of 'a'
```

We invoke find() on word

find() can also find substrings not just characters

```
word.find('na') #2
```

It can take as a second argument the index where it should start:

```
word.find('na',3) #4
```

As a third argument the index where it should stop:

```py
>>> name = 'bob'
>>> name.find('b',1,2)
-1
```

#### in Operator

The word ‘in’ is a Boolean operator that takes two strings and returns true if the first appears as a substring in the second

```py
>>> 'a' in 'banana'
True

>>> 'seed' in 'banana'
False
```

#### String Comparison

Relational operators work on strings

Equality operator ‘==’

Other relational operations are useful for putting words in alphabetical order:

```py
#If you compare strings that contain the same substring, such as Apple and ApplePie, then the longer string is considered larger.

if word < 'banana’:
   print('Your word, ' + word + ', comes before banana in the dictionary.')
elif word > 'banana’:
   print('Your word, ' + word + ', comes after banana in the dictionary.')
else:
   print('All right, bananas.')
```

Uppercase letters come before all the lowercase letters

#### String Operationss

```py
>>> "hello"+"world"  # concatenation
"helloworld"      

>>> "hello"*3  # repetition
"hellohellohello"

>>> "hello"[0] # indexing
"h"      

>>> "hello"[-1] # (from end)
"o"      

>>> "hello"[1:4] # slicing
"ell"      

>>> len("hello") # size
5     

>>> "hello" < "jello" # comparison
True     

>>> "e" in "hello" # search
True     

New line:  "escapes: \n "

Line continuation:  triple quotes ’’’

Quotes:  ‘single quotes’, "raw strings"
```

#### String Methods

• upper()

• lower()

• capitalize()

• count(s)

• find(s)

• rfind(s)

• index(s)

• strip(), lstrip(), rstrip()

• replace(a, b)

• expandtabs()

• split()

• join()

• center(), ljust(), rjust()

### Lists

A sequence type

A sequence of values

These values can be of any type

Values in a list are called items or elements

The simplest way to create a list is to enclose elements in
square brackets ([ and ])

```py
[10, 12, 14, 15]

[‘Tom cat’, ‘Jerry mouse’]

[‘spam’, 21, ‘a’, 34.5]
```

You can assign list values to variables

```
data = [10, 12, 14, 15]
```

Even an empty list,

```
arr = [ ]
```

#### Lists are Mutable

The syntax for accessing list elements is the same as for accessing string characters

The expression inside brackets specifies the index

```py
>>> numbers = [7, 34, 56]
>>> numbers[1] = 36        # list is mutable
>>> print(numbers)
[7, 36, 56]
```

#### Mapping

You can think of a list as a mapping between indices and elements

Each index "maps to" one of the elements

```
num = [2, 34, 56]
```

#### Indices

List indices work the same way as string indices

• Any integer expression can be used as an index

• if you try to read or write an element that does not exist, you get an IndexError

• If an index has a negative value, it counts backward from the end of the list

#### ‘in’ Operator

The ‘in’ operator also works on lists

```py
cheeses = ["Cheddar", "Mozzarella", "Blue"]
"Blue" in cheeses   # True
"Brie" in cheeses   # False
```

#### Traversing a List

The most common way is with a ‘for’ loop

Syntax is the same as for strings

```py
cheeses = ["Cheddar", "Mozzarella", "Blue"]
for cheese in cheeses:
    print(cheese)
```
 works well if you only need to read the elements

If you want to write or update the elements, you need the indices

Common way is to combine functions ‘range’ and ‘len'

```py
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
```

This loop traverses the list and updates each element

#### Nested Lists

A list can contain another list

`[‘spam’, 1, [‘Brie’, 5, 3.2], 2, [2, 5, 6]]`

Each internal list still counts as a single element

#### List Operations

‘+’ operator concatenates lists

```py
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print(c)
[1, 2, 3, 4, 5, 6]
```

‘*’ operator repeats a list a given number of times

```py
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

#### List Slices

Slice operator also works on lists

```py
>>> t = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]
>>> t[1:3]
[‘b’, ‘c’]
>>> t[:4]
[‘a’, ‘b’, ‘c’, ‘d’]
>>> t[3:]
[‘d’, ‘e’, ‘f’]
```

If you omit the first index, the slice starts at the beginning

If you omit the second, the slice goes to the end

If you omit both, the slice is a copy of the whole list

```py
>>> t[:]
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’, ‘f’]
```

#### append() Method

Python provides methods that operate on lists

append adds a new element to the end of a list

```py
>>> t = [‘a’, ‘b’, ‘c’]
>>> t.append(‘d’)
>>> print(t)
[‘a’, ‘b’, ‘c’, ‘d’]
```

#### extend() Method

extend takes a list as an argument and appends all of the elements

```py
>>> t1 = [‘a’, ‘b’, ‘c’]
>>> t2 = [‘d’, ‘e’]
>>> t1.extend(t2)       # append list t2 to t1
>>> print(t1)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
```

t2 is unmodified

#### sort() Method

sort arranges the elements of the list from low to high

```py
>>> t = [‘d’, ‘b’, ‘c’, ‘a’, ‘e’]
>>> t.sort()
>>> print(t)
[‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
```

List methods are all void; they modify the list and return None


```py
# Create a list t, 1,5,6,7
t = [1,5,6,7]
# Print t
print (t)
# copy t to r list
r = t[:]
# not r = t, will only create another pointer to the list
# print r
print (r)
# Modify 2nd element of r
r[1] = 4
# print r
print (r)
# print t
print (t)
# What do you notice?
# t[1] and r[1] are different
r = t[:]
```

#### Deleting Elements

pop() - takes the last element

```py
 >>> t = ['a', 'b', 'c']
 >>> x  = t.pop()
 >>> x
 'c'
```

pop() modifies the list and returns the element that was removed

`t.pop(0)` removes the first element

`del t[1]` del statement also deletes elements, when you don’t need them

#### remove() Method

If you know the element you want to remove (but not the index), use remove():

```py
t = ['a', 'b', 'c']
t.remove('b')
```

The return value from remove is None

To remove more than one element, use del statement

```py
t = [‘a’, ‘b’, ‘c’, ‘d’, ‘e’]
del t[1:5]
```

#### Strings vs. Lists

• A string is a sequence of characters

• A list is a sequence of values

• A list of characters is not the same as a string

• A string is immutable whereas a list is mutable

```py
>>> s = 'spam'
... t = list(s)
... print(t)
['s','p','a','m']
```

#### split() Method

split() method takes a string and parses its words to form a list of strings

```py
>>> s = 'This is an ML class'
... t = s.split()
... print(t)
['This', 'is', 'an', 'ML', 'class']
```

#### Delimiter

A delimiter specifies which characters to use as word boundaries while splitting

```py
>>> s = 'spam-spam-spam'
... t = s.split('-')
... t
['spam', 'spam', 'spam']
```

#### join() Method

join() is the inverse of split()

It takes a list of strings and concatenates the elements to form a single string

```py
>>> t = ['This', 'is', 'an', 'ML', 'class']
... delimiter = ' '
... delimiter.join(t)
'This is an ML class'
```

#### Objects and Values

a and b both refer to a string, but we don’t know whether they refer to the same string

To determine, we can use the ‘is’ operator

```py
>>> a = 'banana'
... b = 'banana'
... a is b
True
```

When you create two lists, you get two distinct objects, even if they have the same elements

```py
>>> a = [1,2,3]
... b = [1,2,3]
... a is b
False

>>> b = a
... b is a
True

>>> b[0] =  17
... a
[17, 2, 3]
```

#### List Arguments

When you pass a list to a function, the function gets a reference to the list

If the function modifies a list parameter, the caller sees the change

Some operations modify lists and other operations create new lists

append() method modifies a list, but the + operator creates a new list

```py
>>> t1 = [1,2]
... t1.append(3)
... t1
[1, 2, 3]
```

The difference is important when you write functions that are supposed to modify lists

```py
>>> t3 = t1 +[4]
... t3
[1, 2, 3, 4]
```

The slice operator creates a new list and the assignment makes t refer to it

```py
>>> def bad_delete_head(t):
...   t = t[1:]
... t1 = [1,2,3]
... bad_delete_head(t1)
... print('t1 is:', t1)
t1 is: [1, 2, 3]
```

None of that has any effect on the list passed as an argument

If we want to slice a list we can return it

The list leaves the original list unmodified

```py
>>> def tail(t):
...   return(t[1:])
... t1 = [1, 2, 3]
... t2 = tail(t1)
... print(t1)
... print(t2)
[1, 2, 3]
[2, 3]
```

#### List Operations

• append

• insert

• index

• count

• sort

• reverse

• remove

• pop

• extend

• Indexing e.g., L[i]

• Slicing e.g., L[1:5]

• Concatenation e.g., L + L

• Repetition e.g., L * 5

• Membership test e.g., ‘a’ in L

• Length e.g., len(L)

#### List Comprehension

• List comprehensions offer a succinct way to create lists based on existing lists

• When using list comprehensions, lists can be built by leveraging any iterable, including strings and tuples

• Syntactically, list comprehensions consist of an iterable containing an expression followed by a for clause

• General Syntax

```
[<output value> <iterator> <conditional stmt>]
```

#### Squaring Numbers

Creating a list of squares of numbers from 1 to 5, without and with list comprehension

```py
squares = []
for i in range(1,6):
  squares.append(i**2)
squares

output:
[1, 4, 9, 16, 25]
```

```py
[x**2 for x in range(1,6)]

output:
[1, 4, 9, 16, 25]
```
Even numbers

```py
[x**2 for x in range(1,6) if x%2 == 0]

output:
[4, 16]
```

Odd numbers

```py
[x**2 for x in range(1,6) if x%2]

output:
[1, 9, 25]
```

#### Using if-else Conditionals

Make the values between 5 and 10 negative (both included)

```py
a = [3,4,5,6,7,8,9,10,1,12,13,14,15]
[-val if 5<=val <=10 else val for val in a]

output:
[3, 4, -5, -6, -7, -8, -9, -10, 1, 12, 13, 14, 15]
```

#### 2D List Creation w/out List Comprehension

```py
import random

data = []
for i in range(5):
  row = []
  for j in range(5):
    row.append(random.randint(1,10))
  data.append(row)

data

output:
[[2, 4, 8, 1, 5],
 [10, 1, 2, 8, 9],
 [7, 4, 1, 8, 2],
 [4, 2, 6, 2, 3],
 [10, 9, 7, 4, 10]]
```

#### 2D List Creation w/ List Comprehension

```py
import random

datal = [[random.randint(1,10) for j in range(5)] for i in range(5)]
datal

output:
[[5, 5, 8, 3, 5],
 [6, 5, 6, 10, 2],
 [8, 9, 7, 4, 9],
 [9, 10, 6, 2, 1],
 [10, 2, 1, 4, 8]]
```

#### Flattening 2D List

```py
datal_flattened = [val for row in datal for val in row]
datal_flattened

output:
[5, 5, 8, 3, 5, 6, 5, 6, 10, 2, 8, 9, 7, 4, 9, 9, 10, 6, 2, 1, 10, 2, 1, 4, 8]
```

### Tuples

#### Introduction

• A sequence type

• A sequence of values

• They are indexed and a lot like lists

• A comma-separated list of values

• It is common to enclose tuples in parentheses

```py
>>> t = 'a', 'b', 'c' # or t = ('a', 'b', 'c')
... t
('a', 'b', 'c')
```

#### Tuples

Tuple is a sequence of values whose elements cannot be modified once it is created. In other words, it's a read-only array

```py
>>> t = ()
>>> t = (1, 2, 3)
>>> t = (1, )
>>> t = 1,  #(1, )
>>> a = (1, 2, 3, 4, 5)
>>> print a[1]   # 2
```

#### List vs. Tuple

What are common characteristics?

• Both store arbitrary data objects

• Both are of sequence data type

What are differences?

• Tuple doesn’t allow modification

• Tuple doesn’t have methods??

• Tuple supports format strings

• Tuple supports variable length parameter in function call

• Tuple slightly faster


#### Tuples

To create a tuple with a single element, you have to include a final comma

```py
>>> t = 'a',
... t
('a',)
```

A single value in parentheses is not a tuple

```py
>>> t = ('a')
... t  #type(t) #str
'a'
```

#### Index Operator

If the argument is a sequence (string, list, or tuple), the result is a tuple with the elements of the sequence

```py
>>> t = ('l','o','g','i','c')
>>> print(t)
('l', 'o', 'g', 'i', 'c')
```

Most list operators also work on tuples

```py
>>> print(t[0])
l
```
#### Slice Operator

Slicing

If you try to modify one of the elements of the tuple

```py
>>> print(t[0])
l
>>> t[0] = 'a'

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [50], in <module>
----> 1 t[0] = 'a'

TypeError: 'tuple' object does not support item assignment
```

Tuples are immutable

#### Assignment

If we want to swap two variables we will need a third variable, for example

```py
>>> a = 25
>>> b = 45
>>> temp = a
>>> a = b
>>> b = temp
>>> print(a)
>>> print(b)
45
23
```

With tuples it is more elegant

```py
>>> print(a,b)
>>> a,b = b,a
>>> print(a,b)
45 25
25 45
```

The right side can be any kind of sequence (string, list, or tuple)

```py
>>> email = 'nayeem@cd.umd.edu'
>>> uname,domain = email.split('@')
>>> print("name:",uname,", domain: ", domain)
name: nayeem , domain: cd.umd.edu
```

#### Tuples as Return Values

```py
>>> quot, rem = divmod(9,4) # quotient and remainder of 9/4
>>> print(quot)
2
>>> print(rem)
1
```

#### Variable-Length Argument Tuples

Functions can take a variable number of arguments

A parameter name that begins with a * gathers arguments into a tuple, for example

```py
def printall(*args):
  print(*args)
printall(1,'3.5',"test")

output:
(1, '3.5', 'test')
```

#### Variable Length Arguments

Many of the built-in functions use variable-length argument tuples

For example, max() and min() can take any number of arguments:

```py
>>> max(3,4,7)
7

>>> min(1,3,6)
1
```

sum cannot

```py
>>> sum(1,3,6)

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [54], in <module>
----> 1 sum(1,3,6)

TypeError: sum() takes at most 2 arguments (3 given)
```

#### Variable Length Tuples

Write a function called sumall() that takes any number of arguments and returns their sum

```py
def sumall(*args):
  s = 0
  for i in args:
    s += i
  return(s)
print(sumall(2,3,4,5))

output:
14
```

#### Tuple Operations

• Indexing e.g., T[i]

• Slicing e.g., T[1:5]

• Concatenation e.g., T + T

• Repetition e.g., T * 5

• Membership test e.g., ‘a’ in T

• Length e.g., len(T)

### Lambda Functions

#### Anonymous (Lambda) Functions

• An anonymous function is a function that is defined without a name

• While normal functions are defined using the def keyword, anonymous functions are defined using the lambda keyword

• Anonymous functions are typically small, and are used to parameterize an expression

• They are typically created near where they are used

• They can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions

• They are used in combination with the functions filter(), map(), and reduce()

#### Lambda Function Syntax

• Syntax

```
lambda <argumentlist>: <expression>
```

• Argument list consists of a comma separated list of arguments

• Expression is an arithmetic expression using these arguments

```py
>>> p = lambda x,y: x*y
>>> p(3,4)
12
```

```py
def m(x,y):
  return(x*y)
m(3,4)

output：
12
```

#### Why Use Lambda Functions?

The power of a lambda function is evident when it is used (as an anonymous function) inside another function

```py
def findlarger():
  value =  lambda x,y: "x is larger" if x >y else "y is larger"
  return(value)

outpuut = findlarger()
print(type(output))
print(output(3,5))

output:
<class 'function'>
y is larger
```

```py
def myfunc(n):
  return lambda a: a*n

mydoubler = myfunc(2) #n=2
mytripler = myfunc(3) #n=3

print(mydoubler(11)) #a=11
print(mytripler(11)) #a=11

output:
22
33
```

#### Functions as parameters

Have you ever wanted to pass an entire function as a parameter

Python has functions as first-class citizens, so you can do this

You simply pass the functions by name

#### Higher-Order Functions

A higher-order function is a function that takes another unction as a parameter

They are "higher-order" because it’s a function of a function

Examples

– Map

– Reduce

– Filter

Lambda works great as a parameter to higher-order functions if you can deal with its limitations

#### map Function

`map()` is a function with two arguments

`r = map(func, seq)`

the first argument func is the name of a function

the second is a sequence (e.g., a list) seq

#### map Function without lambda

```py
def celsius(T):
  return((5/9)*(T-32.))
def fahrenheit(T):
  return((9/5)*T + 32)

temperatures = (-10, -20, -30, 30, 40)
F = map(fahrenheit,temperatures)
temp_in_fahrenheit = list(F)
print("Temperature in Fahrenheit: ", temp_in_fahrenheit)

output:
Temperature in Fahrenheit:  [14.0, -4.0, -22.0, 86.0, 104.0]
```

```py
C = map(celsius, temp_in_fahrenheit)
temp_in_celsius = list(C)
print(temp_in_celsius)

output:
[-10.0, -20.0, -30.0, 30.0, 40.0]
```

#### map Function with lambda

```py
C = [-10, -20, -30, 30, 40]
F = list(map(lambda x: ((9/5)*x + 32), C))
print("Fahrenheit temp: ", F)
C = list(map(lambda x:((5/9) * (x - 32)), F))
print("Celsius: ", C)

output:
Fahrenheit temp:  [14.0, -4.0, -22.0, 86.0, 104.0]
Celsius:  [-10.0, -20.0, -30.0, 30.0, 40.0]
```

#### map() with Multiple Lists

• map() can be applied to more than one list

• The lists have to have the same length

• map() will apply its lambda function to the elements of the argument lists

• It first applies to the elements of the 0th index, then to the elements with the 1st index, so on


```py
a = [1,2,3,4]
b = [17,12,11,10]
c = [-1,-4,5,9]
sumAB = list(map(lambda x,y: x+y,a,b))
print("sumAB: ", sumAB)

sumABC = list(map(lambda x,y,z:x+y+z,a,b,c))
print("sumABC: ", sumABC)

expABC = list(map(lambda x,y,z:2.5*x+2*y-z,a,b,c))
print("expABC: ", expABC)

output:
sumAB:  [18, 14, 14, 14]
sumABC:  [17, 10, 19, 23]
expABC:  [37.5, 33.0, 24.5, 21.0]
```

#### Filtering

• filter function filters out all the elements of a list, for which function returns True
```
filter(<function>, list)
```

• function, f, is the first argument.

• f returns a Boolean value, i.e. either True or False

• This function will be applied to every element of the list

• Only if f returns True will the element of the list be included in the result list

```py
data = [1,3,4,8,5,26]
odd_numbers = list(filter(lambda x : x%2, data))
even_numbers = list(filter(lambda x: x%2==0, data))
print(odd_numbers) # prints [1, 3, 5]
print(even_numbers) # prints [4, 8, 26]
```

#### reduce

• Function reduce continually applies function to the sequence reduce (func, seq)

• If seq = [s1,s2,s3,...,sn], calling reduce(func, seq) works like this

- At first, func will be applied to s1 and s2

- In the next step, func will be applied to the result of step 1 result and s3, and so on


```py
from functools import reduce

data1 = [34,43,56,76]
m = reduce(lambda x,y:x+y, data1)
print(m) # prints sum of list elements (209)

sum = reduce(lambda x,y: x+y, range(1,101))
print(sum) #5050

largest = reduce(lambda x,y : x if x > y else y, [3,25,23,12,4,9])
print(largest) #25

```

#### array

• Arrays are sequence types and behave very much like lists, except that the type of objects stored in them is constrained

•  The type is specified at object creation time by using a type code, which is a single character.

```py
from array import array

a = array('f',[2,4,6,8])
print(a) #array('f', [2.0, 4.0, 6.0, 8.0])

array('f', [2.0, 4.0, 6.0, 8.0]) #array('f', [2.0, 4.0, 6.0, 8.0])

help(array)
```

### Zip

• zip is a built-in function that takes two or more sequences (lists, sets, etc.), and

• "zips" them into a list of tuples, where each tuple contains one element from each sequence

• Returns a zip object, use the tuple() function or list() function to print a readable version of the result

#### Lists and Tuples

```py
>>> s = 'abc'
>>> t = [0,1,2]
>>> zip(s,t)
<zip at 0x1c9de3ba080> # Need to use tuple() or list() to print
```

The result is a list of tuples, where each tuple contains a character from the string and the corresponding element from the list

#### Hashing from Two Arrays

```py
>>> keys = ['x','y','z']
>>> values = [24,25,26]

>>> d = zip(keys,values)
>>> list(d)
[('x', 24), ('y', 25), ('z', 26)]

>>> d1 = list(d)
>>> d1[0]
('x', 24)
```

```py
>>> s1 = {1,3,2} # s1 and s2 are sets (unordered)
>>> s2 = {'c','b','a'}
>>> s3 = list(zip(s1,s2))
>>> s3
[(1, 'c'), (2, 'a'), (3, 'b')]

>>> S1_new, s2_new = zip(*s3)
>>> S1_new
(1, 2, 3)
>>> s2_new
('c', 'a', 'b')
```

#### Hashing from More than 2 Arrays

```py
>>> l1 = [1,2,3,4]
>>> l2 = ['a','b','c','d']
>>> l3 = [2.0,3.0,4.0,5.0]

>>> l4 = zip(l1,l2,l3)
>>> list(l4)
[(1, 'a', 2.0), (2, 'b', 3.0), (3, 'c', 4.0), (4, 'd', 5.0)]
```

Unzip a list of tuples

```py
>>> x,y,z = zip(*l)
>>> print(x)
(1, 2, 3, 4)
>>> print(y)
('a', 'b', 'c', 'd')
>>> print(z)
(2.0, 3.0, 4.0, 5.0)
```

#### Hashing from Diff. Sized Arrays

```py
>>> list(zip(range(5),range(50)))
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]
```

```py
from itertools import zip_longest

a = [1,2,3]
b = ['x','y','z']
c = range(5)

d = zip_longest(a,b,c,fillvalue='*')
list(d)

output：
[(1, 'x', 0), (2, 'y', 1), (3, 'z', 2), ('*', '*', 3), ('*', '*', 4)]
```

```py
from itertools import zip_longest

x =[1, 2, 3, 4, 5, 6, 7]
y =[8, 9, 10]
z = list(zip_longest(x, y))
print(z)

output:
[(1, 8), (2, 9), (3, 10), (4, None), (5, None), (6, None), (7, None)]
```

This iterator falls under the category of Terminating Iterators. It prints the values of iterables alternatively in sequence. If one of the iterables is printed fully, the remaining values are filled by the values assigned to fillvalue parameter.

#### Sorting in Parallel



```py
>>> a = [1,3,2]
>>> b = ['c','b','a']

>>> c = list(zip(a,b))
>>> print(c)
[(1, 'c'), (3, 'b'), (2, 'a')]
>>> print(c.sort())
[(1, 'c'), (2, 'a'), (3, 'b')]

>>> d = list(zip(b,a))
>>> print(d)
[('c', 1), ('b', 3), ('a', 2)]
>>> print(d.sort())
[('a', 2), ('b', 3), ('c', 1)]
```

### Dictionaries

#### Dictionary

An unordered set of key: value pairs

• A mapping between keys and values

• Like an array indexed by a string

• Values of any type; keys of almost any type

• curly brackets

```
{"name":"Guido", "age":43, ("hello","world"):1, 42:"yes", "flag": ["red","white","blue"]}
```

```py
>>> d = {"foo" : 1, "bar" : 2}
>>> print (d["bar"])       
2

>>> dict1 = {}
>>> dict1["foo"] = "yow!"
>>> print (dict1.keys())   
dict_keys([‘foo’])
```

#### Dictionary Details

Keys are immutable

• numbers, strings, tuples of immutables, these cannot be changed after creation

• reason is hashing (fast lookup technique)

• **not** lists or other dictionaries, these types of objects can be changed "in place"

• no restrictions on values

Keys will be listed in arbitrary order, because of hashing

#### Dictionary vs. List

• A dictionary is like a list

• In a list, the indices must be integers

• In a dictionary they can be almost any type

• And a dictionary is a mapping between keys and values

#### Methods in Dictionary

• keys()

• values()

• items()

• has_key(key)

• clear()

• copy()

• get(key[,x])

• setdefault(key[,x])

• update()

• popitem()

#### Initialization

The ‘in’ operator works on the keys in a dictionary

```py
>>> en2Ks = dict() # Either one will create an empty dictionary
>>> en2Ks = {}

>>> en2Ks = {'one':'akh','two':'ze','three':'tre'}
>>> 'one' in en2Ks
True
```

#### Using zip()to form a Dictionary

Form a dictionary from a keys list and a values list using zip

```py
>>> keys = ['x','y','z']
>>> values = [24,25,26]
>>> d = {k:v for k,v in zip(keys,values)}
>>> d
{'x': 24, 'y': 25, 'z': 26}
```

#### Dictionary Comprehension

Like list comprehension, we can create dictionaries using simple expressions

A dictionary comprehension takes the form '{key: value for (key, value) in iterable}'

E.g.: Convert the values to floating point values

```py
>>> weight = {'a':35,'b':100,'c':175}
>>> float_weight = {key:float(value) for key,value in weight.items()}
>>> float_weight
{'a': 35.0, 'b': 100.0, 'c': 175.0}
```

#### Dictionary Comprehension: Alphabet

Create a list of the alphabet

```py
>>> import string

>>> alphabet = list(string.ascii_lowercase)
>>> print(alphabet,)
['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
```

Create a dictionary with keys as the letters and the values as their position in the alphabet


```py
>>> print({alphabet[i-1]:i for i in range(1,len(alphabet)+1)})
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25, 'z': 26}
```

#### Values

To see whether a value exists, use a method called values()

```py
'ze' in en2Ks.values() #True
```

#### ‘in’ Operator Algorithms

‘in’ operator uses different algorithms for lists and dictionaries

For lists, it uses a search algorithm

For dictionaries, it uses a hashtable

In a hashtable, the ‘in’ operator takes about the same time no matter how many items there are in a dictionary

#### Looping and Dictionaries

You can use a ‘for’ loop to traverse the keys of a dictionary

```py
>>> for key in en2Ks:
...   print(key,en2Ks[key])

one akh
two ze
three tre
```

Dictionaries have a method called keys that returns the keys of the dictionary, in no particular order, as a list


#### Reverse LookUp

Given a dictionary ‘d’ and a key ‘k’

We can find the value using

   v = d[k]

   This is called lookup

If you have v and you want to find k, you have two problems

• there might be more than one key that maps to the value v

• there is no method for reverse lookup, you have to search for it

#### Dictionaries and Lists

Lists can appear as values in a dictionary

Consider a dictionary that maps frequencies to letters

A frequency may be mapped to several letters

In order to represent such a mapping, the values (letters)
should be a list of letters

lists cannot be keys
```py
t = [1,2,3]
d = dict()
d[t] = 'oops'
```

#### Data Type Wrap Up

• Integers: 2323, 3234

• Floating Point: 32.3, 3.1E2

• Complex: 3 + 2j, 1j

• Lists: l =  [1,2,3]

• Tuples: t = (1,2,3)

• Dictionaries: d = {‘hello’ : ‘there’, 2 : 15}

• Lists, Tuples, and Dictionaries can store any type (including other lists, tuples, and dictionaries!)

• Only lists and dictionaries are mutable

• All variables are references

### Files

#### Introduction

Most of the programs written so far run for a short duration. Once the program ends, the data is gone. If we want to see the results again, we have to run the program again

#### Persistence

Some programs run for a long time. They store data permanently.

The data is available even after the program ends. For example, operating systems and web servers.

One way to read and write data is using files.

Another way to store data is using a database

#### Reading a File

Using a built-in function ‘open’

It takes the name of a file and returns a file object

```py
fin = open('../Lectures/words.txt')
fin
```

#### readline()

It can read one line

```py
>>> fin = open('words.txt')
>>> fin.readline()
'MSML 605\n'
```

readlines() reads lines into a list

```py
>>> fin.readlines()
['Course\n','Spring 2020']
```

#### Removing End of Line Character

remove end line character

```py
>>> fin = open('words.txt')
>>> fin.readline().strip('\n')
'MSML 605'
```

#### File Traversal

```py
fin = open('words.txt')

for line in fin:
  print(line)
fin.close()

output:
MSML 605

Course

Spring 2020
```

#### Writing

To write to a file, you have to open it with mode ‘w’ as a second parameter

```py
fout = open("output.txt", 'w')
```

If the file already exists, opening it in write mode clears out the old data and starts fresh

#### Write to a File

```py
Line1 = "This is a ML class\n"
fout.write(line1)

Line2 = "We Program in Python language\n"
fout.write(line2)
fout.close()
```

#### Format Operator

The argument of write has to be a string.

If we want to put other values in a file, we have to convert them to strings

```py
f = open('output.txt', 'w')
x = 53
f.write(str(x))
```

An alternative is to use the format operator, %

#### Format Sequence

For example, the format sequence ‘%d’ means that the second operand should be formatted as an integer

```py
>>> camels = 42
>>> '%d' % camels
'42'
```

A format sequence can appear anywhere in the string

So you can embed a value in a sentence

```py
>>> camels = 42
>>> 'I have spotted %d camels.' % camels
'I have spotted 42 camels.'
```

For more than one format sequence in a string, the second argument is a tuple

Each format sequence with an element of the tuple, in order

Format Sequences used to format

• ‘%d’ an integer

• ‘%g’ a floating-point number

• ‘%s’ a string


```py
>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')
'In 3 years I have spotted 0.1 camels.'
```

#### Sequence Formatting Rules & Errors

The number of elements in the tuple has to match the number of format sequences in the string

Also, the types of the elements have to match the format sequences

```py
'%d %d %d' % (1,2)
---------------------------------------------------------------------------
TypeError            Traceback (most recent call last)
Input In [29], in <module>
----> 1 '%d %d %d' % (1,2)

TypeError: not enough arguments for format string
```

```py
'%d' % 'dollars'
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Input In [30], in <module>
----> 1 '%d' % 'dollars'

TypeError: %d format: a real number is required, not str
```

#### Filenames and Paths

import os: os module provides functions for working with files and directories

```py
>>> import os
>>> cwd = os.getcwd()
>>> print(cwd)
/users/george
```

To find the absolute path to a file, you can use os.path.abspath

```py
>>> os.path.abspath('words')
'/users/george/words'
```

os.path.exists checks whether a file or directory exists

```py
>>> os.path.exists('words.txt')
False
```
os.path.isdir checks whether it’s a directory

```py
>>> os.path.isdir('Documents')
True
```
os.path.isfile checks whether it’s a file

```py
>>> os.path.isfile('test')
True
```

os.listdir returns a list of the files ( and other directories) in the given directory

```py
>>> os.listdir('/users')
['.localized', 'Guest', 'george', 'Shared']
```

Walk through a directory

```py
import os
def walk(dirname):
  for name in os.listdir(dirname):
    path = os.path.join(dirname,name)
    if os.path.isfile(path):
      print(path)
    else:
      walk(path)
```

```py
train_img_names = [os.path.join(training_path,f) for f in os.listdir(training_path) if
f.endswith('.jpg')]
```

#### Catching Exceptions

If you try to open a file that doesn’t exist, it will throw an error:

```py
>>> fin = open('our_file')
FileNotFoundError: [Errno 2] No such file or directory: 'our_file'
```

If you don’t have permission to access a file:

```py
>>> fout = open('/etc/passwd','w')
PermissionError: [Errno 13] Permission denied: '/etc/passwd'
```

If you try to open a directory for reading, you get:

```py
>>> fin = open('/home')
IsADirectoryError: [Errno 21] Is a directory: '/home'
```

#### try and except

There is an option using 'try' and 'except' so that the program does not halt when there is an error

```py
try:
  fin = open('bad_file')
  for line in fin:
    print(line)
  fin.close()
except:
  print('Something went wrong')
```

Python starts by executing the try clause

If all goes well, it skips the except clause and proceeds

If an exception occurs, it jumps out of the try clause

```py
try:
  print(x)
except NameError:
  print("Variable x is not defined")
except:
  print("Something else went wrong")
```

You can use the else keyword to define a block of code to be executed if no errors were raised:

```py
try:
  print("Hello")
except:
  print("Something went wrong")
else:
  print("Nothing went wrong")
```
#### Pickling

A pickle module is used to store Python objects in a database

Import the pickle module first. Then use pickle.dump() function to store the object data to the file. pickle.dump() function takes 3 arguments. The first argument is the object that you want to store. The second argument is the file object you get by opening the desired file in write-binary (wb) mode. And the third argument is the key-value argument.

```py
import pickle

# take user input to take the amount of data
number_of_data = int(input('Enter the number of data : '))
data = []

# take input of the data
for i in range(number_of_data):
    raw = input('Enter data '+str(i)+' : ')
    data.append(raw)

# open a file, where you ant to store the data
file = open('important', 'wb')

# dump information to that file
pickle.dump(data, file)

# close the file
file.close()

output:
Enter the number of data :
Enter data  0 :  123
Enter data  1 :  abc
Enter data  2 :  !@#$
```

To retrieve pickled data, the steps are quite simple. You have to use pickle.load() function to do that. The primary argument of pickle load function is the file object that you get by opening the file in read-binary (rb) mode.

```py
import pickle

# open a file, where you stored the pickled data
file = open('important', 'rb')

# dump information to that file
data = pickle.load(file)

# close the file
file.close()

print('Showing the pickled data:')

cnt = 0
for item in data:
    print('The data ', cnt, ' is : ', item)
    cnt += 1

output:
Showing the pickled data:
The data  0  is :  123
The data  1  is :  abc
The data  2  is :  !@#$
```

```py
import pickle
t = [1,2,3]
s = pickle.dump(t, open("temp", "wb"))
t2 = pickle.load(open("temp", "rb"))
print(t2)

output:
prints [1, 2, 3]
```

```py
import pickle
dic = {"k1":"v1","k2":123}
s = pickle.dumps(dic)
dic2 = pickle.loads(s)
dic2

output:
{'k1': 'v1', 'k2': 123}
```

Although the new object has the same value as the old, it is not the same object

```py
print (t == t2)  # True
print (t is t2)  # False
```

## Chapter 4 Objects

#### Outline

Objects, classes, instances, and object-oriented programming

• Relationship between classes and instances

• Abstraction

Anatomy of a class

• Instance variables

• Instance methods

• Constructors

#### Object-Oriented Basics

Object: A single software unit that combines attributes and methods

• Attribute: A "characteristic" of an object; like a variable associated with a kind of object

• Method: A "behavior" of an object; like a function associated with a kind of object

Class: Code that defines the attributes and methods of a kind of object (A class is a blueprint of an object)

• we have seen so far: str, list, dict, etc.

OOP (Object-oriented programming) allows

• representation of real-life objects as software objects (e.g., a dictionary as an object)

• writing programs that perform most of their behavior as interactions between objects

#### Fundamental Concepts of OOP

Information hiding

Abstraction

Encapsulation: hiding design details to make the program clearer and more easily modified later

Modularity: the ability to make objects stand alone so they can be reused

Polymorphism: Allow one message to be sent to any object and have it respond appropriately based on the type of object it is

Inheritance: create a new object by inheriting (like father to son) many object characteristics while creating or over-riding for this object

#### Abstraction

Distancing between ideas and details

Objects in Python provide abstraction: We can use them without knowing how they work

You use abstraction every day like a smart phone. We understand its external behavior (home button, screen, etc.). We don't understand its inner details (and don't need to)

#### Encapsulation

Hiding implementation details of an object from clients

Encapsulation provides abstraction: we can use objects without knowing how they work

The object has:

• an external view (its behavior)

• an internal view (the state and methods that  accomplish the behavior)

#### Class versus Instance

The analogy of the cookie cutter and cookie

The cutter is a template for stamping out cookies; the cookie is what is made each time the cutter is used

One template can be used to make an infinite number of cookies, each one having the same shape as the other

No one confuses a cookie for a cookie cutter, do they?

#### Class versus Instance

You define a class as a blueprint to generate new instances of that class

• Instances are objects that are created based on the definition given inside the class

Both the class and the instances are themselves objects

The structure of each instance starts out the same, as dictated by the class

The instances respond to the methods defined as part of the class

#### Class versus Instance
```py
Music player blueprint:

State:
current song
volume
battery life  

Behavior:  
power on/off
change station/song
change volume
choose random song
```

```py
Music player #1

state:
song = "Let it snow"  
volume = 17
battery life = 2.5 hrs

behavior:
power on/off
change station/song  
change volume  
choose random song
```

```py
Music player #2

state:
song = "Galaxy song"  
volume = 9
battery life = 3.41 hrs

behavior:
power on/off  
change station/song  
change volume  
choose random song
```

```py
Music player #3
state:
song = "Code Monkey"  
volume = 24
battery life = 1.8 hrs

behavior:
power on/off
change station/song  
change volume  
choose random song
```

### Defining Classes in Python

#### In Pythion, it’s all Objects...

In case you haven’t noticed, everything in Python is really an object

• We’ve seen hints of this already through built-in classes and their methods ...
```py
"hello".upper()
list3.append('a')
dict2.keys()
```

• These look like Java or C++ method calls

• We can define new object classes in addition to these built-in data-types

In fact, programming in Python is typically done in an object-oriented fashion

#### Data Type vs Class

There is a strong similarity between Python data types and Python classes

Data types

• Seen many data types already: list, dict, str, ...

• Suitable for representing different data

• Respond to different methods regarding the manipulation of that data

Classes are more complicated, user-defined data types

#### Standard Class Names

The standard way to name a class in Python is called CapWords

• Each word of a class begins with a Capital letter

• No underlines

• Sometimes called CamelCase

• Makes it easier to recognize a class

#### Defining a Class

Python doesn’t use separate class interface definitions as in some languages

You just define the class and then use it

Declaring a class
```py
class Name:
  statements
```

Example
```py
class Point:    
  x = 0
```

The class definition is terminated by a blank line

#### Variables and Methods

The class description may define:

•  a set of variables (attributes)

• A set of methods

Variables are for storing data

Methods are for specifying behavior

#### Class Variables (Attributes)

Owned by the class as a whole  

• All class instances have access to the class variable

• They share the same value for it

• If one instance changes the value, all instances see the change

Called "static" variables in some languages  

Stored in pre-defined class variable `ClassName.__dict__`

Good for

• class-wide constants

• building counter of how many instances of the class have been made

#### Declaring a Class Attribute

A class attribute can be declared and initialized

• Inside class, but outside of any method

• In constructor methods

• Outside class

```py
class Point:
  x = 0 # inside class
  def __init__(self):
    self.__class__.y = 1 # in constructor

Point.z = 2 # Outside class
```

#### Referencing a Class Variable

Class variable references use standard syntax. E.g.,

```py
class Point:
"""A simple example class"""
    x = 2
    def f(self):
      return 'hello world'
```

• Point.x would return an integer, and Point.f would return an object

• Class attributes, like Point.x, can have their values changed by assignment

• `__doc__` is also a valid attribute and will return the docstring belonging to the class. i.e., "A simple example class"

### Instantiation

#### Instantiation

When Python encounters a class definition, it automatically creates a function with the same name as the class

• This function is called a constructor

By calling the constructor function (with no parameters), you can create an instance of the class

• Creates an empty object

• Good to assign the result to a variable (name of created instance)

• Instance inherits a personal set of variables (same names as the class variables)

```py
class Point:
   x = 0
   y = 0

# main
p1 = Point()         # p1 is an object of class Point
p1.x = 2
p1.y = -5
```

#### Instantiation Using \_\_new\_\_

Another way to create an instance of a class is to use the class' built-in method `__new__`

The first argument when calling `__new__` is the class name

```py
class Point:
  x = 0
  y = 0

p1 = Point.__new__(Point)
p1.x = 2
P1.y = 3
```

#### Instance Variables & Behavior

Like classes, instances also have state and behavior  

Instance variables: define state of the instance

Instance methods: define behavior for each object of a class. Methods are the way objects communicate with each other and with users

#### Instance Variables

Instance inherits a personal set of variables (same names as the class variables) from its class at time of creation

Stored in pre-defined instance variable: `instanceName.__dict__`

The first argument when calling `__new__` is the class name

```py
class Point:
  x = 0
  y = 0

p1 = Point()
p1.x = 2        # different from Point.x
p1.y = 3
p1.z = 4        # z is instance variable only
```

#### Referencing an Instance Variable

Instance variable references also use standard syntax. E.g.,

```py
class Point:
  """A simple example class"""
  x = 0
  y = 0

p1 = Point()
p1.x = 2
Point.x # prints 0
```

• p1.x refers to instance variable x

• Point.x refers to class variable x

#### Instance Knows its Class

Because an instance has as its type the class that it was made from, each instance remembers its class

This is often called the instance-of Relationship

Stored in the `instanceName.__class__` attribute

#### Review: Two Kinds of Attributes

The non-method data stored by objects are called attributes  

Instance attributes

• Owned by a particular instance of a class

• Each instance has its own value for it

• These are the most common kind of attribute

Class attributes

• Owned by the class as a whole  

• All class instances share the same value for it

• Called "static" variables in some languages  

• Good for:

•  class-wide constants

• keeping count of how many instances of the class have been made

#### Instance vs. Class Attributes

```py
class counter:
  overall_total = 0
     # class attribute
  def __init__(self):
    self.my_total = 0
      # data attribute
  def increment(self):
    counter.overall_total = \
    counter.overall_total + 1
    self.my_total = \
    self.my_total + 1
```

```py
>>> a = counter()
>>> b = counter()
>>> a.increment()
>>> b.increment()
>>> b.increment()
>>> a.my_total
1
>>> a.__class__.overall_total
3
>>> b.my_total
2
>>> b.__class__.overall_total
3
```

#### Importing a Class

`import class`

Client programs must import the classes they use

remember
```py
class Point:
  x = 0
  y = 0
```

```py
from Point import *

# main
p1 = Point()
p1.x = 7
p1.y = -3

# Python objects are dynamic (can add fields any time!)
p1.name = "John Smith"
```

```py
class MyClass(object):
  pass  # The pass keyword signifies that you have intentionally left some part of a definition (of a function, of a class) undefined

my_instance = MyClass()
MyClass.class_attribute = 'hello'
my_instance.instance_attribute = 'world'

dir(my_instance)
#[‘__class__’, ... , ‘class_attribute’, ‘instance_attribute’]


print(my_instance.__class__)
# <class ‘__main__.MyClass’>

type(my_instance)
# <class ‘__main__.Myclass’>

print(my_instance.instance_attribute)
# world

print(my_instance.class_attribute)
#hello

print(MyClass.instance_attribute)

---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [3], in <cell line: 10>()
      5 MyClass.class_attribute = 'hello'
      6 my_instance.instance_attribute = 'world'
---> 10 print(MyClass.instance_attribute)

AttributeError: type object 'MyClass' has no attribute 'instance_attribute'
```

#### Deleting Instance: No Need to free

When you are done with an object, you don’t have to delete or free it explicitly

Python has automatic garbage collection

Python will automatically detect when all of the references to a piece of memory have gone out of scope. Automatically frees that memory

Generally works well, few memory leaks

There’s also no "destructor" method for classes

### Object Behavior: Methods

#### Method versus Function

Method and function are closely related. They are both "small programs" that have parameters, perform some operation and (potentially) return a value

Main difference is that methods are functions tied to a particular object

Functions are called, methods are called in the context of an object

function:

`do_something(param1)`

method:

`an_object.do_something(param1)`

This means that the object that the method is called on is always implicitly a parameter!

#### Methods in a Class

We can define a method inside a class by including function definitions within the scope of the class block

Beware – data attributes override method attributes with the same name!

The first argument of every method is a reference to the current instance of the class

By convention, we name this argument `self`


```py
def name(self, parameter, …, parameter):
  statements

class Point:
  def translate(self, dx, dy):
    self.x += dx
    self.y += dy
    ...
```

#### Implicit Parameter (self)

`self` is a reference to the current instance. `self` lets you access all the instance variables for the specific instance you’re working with

Java: this, implicit
```Java
public void translate(int dx, int dy) {
  x += dx; // this.x += dx;
  y += dy; // this.y += dy;
}
```

Python: self, explicit

```py
def translate(self, dx, dy):
  self.x += dx
  self.y += dy
```

#### Exercise

Write methods `for distance, set_location`, and `distance_from_origin`

```py
from math import *

class Point:
  x = 0
  y = 0
  def set_location(self, x, y):
    self.x = x
    self.y = y
  def distance_from_origin(self):
    return sqrt(self.x * self.x + self.y * self.y)
  def distance(self, other):
    dx = self.x - other.x
    dy = self.y - other.y
    return sqrt(dx * dx + dy * dy)
```

#### Calling a Method of an Object

A client can call a method of an object using the dot notation in one of 2 ways

The value of self can be an implicit or explicit parameter

1) object.method(parameters)

 or

2) Class.method(object, parameters)

```py
#Examples:
p = Point(2, 3)
p.translate(1, 5)
Point.translate(p, 1, 5)
```

Class & Object: Another Example

```py
class test():
  """ Example class"""
  x = 14
  def t(self):
    return('test class')

r = test()
print(r.x)
a = r.t()
print(a)

output:
14
test class
```

### Special Built-In Methods and Attributes

#### Built-In Members of a Class

A class contains many methods and attributes that are included by Python even if you don’t define them explicitly

• Most of these methods define automatic functionality triggered by special operators or usage of that class

• The built-in attributes define information that must be stored for all classes

All built-in members have double underscores around their names:  `__init__`,  `__doc__`

#### Built-in Data Attributes

These attributes exist for all classes

`__doc__` : Variable for documentation string for class

`__class__` : Variable which gives you a reference to the class from any instance of it

`__module__` : Variable which gives a reference to the module in which the class is defined

`__dict__` : The dictionary that is actually the namespace for a class (but not its superclasses)

dir(x) returns a list of all methods and attributes defined for object x

#### Special Data Attributes:

```py
>>> f = student("Bob Smith", 23)

>>> print f.__doc__
A class representing a student.

>>> f.__class__
< class studentClass at 010B4C6 >

>>> g = f.__class__("Tom Jones", 34)
```

#### Magic (or Dunder) Methods

Special methods with 2 prefix and 2 suffix underscores

```py
__new__
__init__  : The initializer for the class
__add__
__len__  : Define how  len( obj ) works
__repr__
__str__
__cmp__  : Define how == works for class
__copy__  : Define how to copy a class
```

#### Magic Methods

Class definition comes with built-in magic methods

• You can write your own `__new__`, `__init__`, ... methods to override the built-in default magic methods

• Never name a function of your own with leading and trailing double underscores

Other built-in methods allow you to give a class the ability to use [ ] notation like an array or ( ) notation like a function call

#### Constructor Method \_\_new\_\_

Automatically called when a class function is called to create a new instance

• Allocates space in memory for the new instance

• Implicitly returns the newly created instance object

Built-in `__new__` is good enough unless you are doing something exotic (control the creation of the instance)

User-defined `__new__` overrides built-in `__new__`

Format

```py
def __new__(cls,  *args, **kwargs):
  statements
```

• `__new__`method can take any number of arguments

• In `__new__`, cls refers to the class for which the instance is created

#### Custom __new__: Example

```py
class Point:
  def __new__(cls):
    print ("Point.__new__called")
    return super(Point, cls).__new__(cls)
  x = 0
  y = 0


p = Point() #Point.__new__called

p.x #0
```

#### super()

Called by `__new__`

Without super(), no instance is created

```py
class Point:
  def __new__(cls):
    print ("Point.__new__ called")
    #return super(Point, cls).__new__(cls)
  x = 0
  y = 0


p = Point() #Point.__new__ called

p.x
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
Input In [38], in <module>
----> 1 p.x

AttributeError: 'NoneType' object has no attribute 'x'
```

Example:

```py
class A:
  def add(self, x):
    y = x+1
    print(y)

class B(A):
  def add(self, x):
    super().add(x)

b = B()
b.add(2)  # 3
```

Example:

```py
class Mammal(object):
  def __init__(self, mammalName):
    print(mammalName, 'is a warm-blooded animal.')

class Dog(Mammal):
  def __init__(self):
    print('Dog has four legs.')
    super().__init__('Dog')

d1 = Dog()

output:
Dog has four legs.
Dog is a warm-blooded animal.
```

#### Custom \_\_new\_\_ w/ Parameters

```py
>>> class MagicMethods:
...    def __new__(cls, *args, **kwargs):
...      print ("MagicMethods.__new__ called")
...      print (cls)
...      print (args)
...      print (kwargs)
         #No instance created, as super() is not called from __new__


>>> nstance1 = MagicMethods(5)
MagicMethods.__new__ called
<class '__main__.MagicMethods'>
(5,)
{}

>>> instance2 = MagicMethods(5, 1, x=2, y=3)
MagicMethods.__new__ called
<class '__main__.MagicMethods'>
(5, 1)
{'x': 2, 'y': 3}
```

#### Initializer Method \_\_init\_\_

Special method for initializing the attributes of an instance (as well as defining new instance variables) during instance creation

Returns nothing

If defined, overrides built-in `__init__`

```py
def __init__(self, parameter, ..., parameter):
  statements
```

`__init__` method can take any number of arguments

In `__init__`, self refers to the instance just created by `__new__`

Should not return anything

#### Custom \_\_init\_\_: Example

```py
class Point:
  def __init__(self, x, y):
    self.x = x
    self.y = y
  x = 0
  y = 0

 p = Point(2, 3)      # p.x = 2, p.y = 3
 p.x                  # instance variable 2
 Point.x              # class variable 0
```

#### \_\_init\_\_: Another Example

```py
class Student:
  """A class representing a student """
  def __init__(self,n,a):
    self.full_name = n
    self.age = a
  def get_age(self):
    return self.age

b = Student("Bob", 21)
```

The arguments passed to the class name are given to its `__init__`()  method

• The __init__ method for student is passed "Bob" and 21

• the new instance (object) is bound to b

#### Custom \_\_new\_\_ and \_\_init\_\_

```py
>>> class Point:
      def __new__(cls, *args, **kwargs):
        print ("Point.__new__ called")
        return super(Point, cls).__new__(cls)

      def __init__(self, x, y):
        print ("Point.__init__ called")
        self.x = x
        self.y = y

>>> p = Point(2, 3) # p.x = 2, p.y = 3
Point.__new__ called
Point.__init__ called

>>> p.x
2
```

#### Printing Objects

```py
>>> student1 = Student("John", 20)
>>> print (student1)
<__main__.Student object at 0x0000016D79BB0760>
```

Doesn’t look so good!

Override built-in `__str__` method with custom `__str__`

```py
def __str__(self):
  return "Name: " + self.full_name+\
         "; Age: " + str(self.age)


>>> student1 = Student("John", 20)
>>> print (student1)
Name: John; Age: 20
```

#### \_\_str\_\_ Method

```py
def __str__(self):
  return string
```

Converts object to a string

Invoked automatically when str or print is called

Exercise: Write a custom `__str__` method for `Point` class that returns strings like  "(3, -14)"

```py
def __str__(self):
  return "(" + str(self.x) + ", " + str(self.y) + ")"
```

#### Complete Point Class

```py
from math import *

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distance_from_origin(self):
        return sqrt(self.x * self.x + self.y * self.y)

    def distance(self, other):
        dx = self.x - other.x
        dy = self.y - other.y
        return sqrt(dx * dx + dy * dy)

    def translate(self, dx, dy):
        self.x += dx
        self.y += dy

    def __str__(self):
        return "(" + str(self.x) + ", " + str(self.y) + ")"
```

#### \_\_repr\_\_ Method

The built-in method `__repr__` specifies how to turn an instance of the class into a string

• `print f` sometimes calls  `f.__repr__()` to produce a string for object f

• If you type  f  at the prompt and hit ENTER, then you are also calling  `__repr__`  to determine what to display to the user as output

#### Custom \_\_repr\_\_: Example

```py
class Student:
  ...
  def __repr__(self):
    return "I’m named " + self.full_name
  ...

>>> f = student("Bob Smith", 23)
>>> print (f)
I’m named Bob Smith
>>> f
"I’m named Bob Smith"
```

### An Example Program: Snake Eyes

#### Probability to get Snake Eyes

write a program that simulates the process

#### Die Class

```py
class Die:
  faceValue = 0
  def  __init__ (self,faces):
    self.numFaces = faces

  def roll(self):
    faceValue = random.randrange(1,self.numFaces + 1)
    return faceValue
```

#### Die Object

State (data) of a Die object:


Instance variable|Description
---|---
numFaces|the number of faces for a die
faceValue|

Behavior (methods) of a Die  object:

Method name|Description
---|---
roll()|roll the die

#### Initializing Objects

When we create a new instance, we can assign values to all or some of its instance variables

```py
die1 = Die(6)
```

#### Die Class

The class (blueprint) knows how to create objects

```py
Die class

state:
faceValue = 0

behavior:
roll()
getFaceValue()
```
```py
Die object #1

state:
numFaces = 6
faceValue = 2

behavior:
roll()  
getFaceValue()
```

```py
Die object #2

state:
numFaces = 6
faceValue = 5

behavior:
roll()  
getFaceValue()
```

```py
Die object #3

state:
numFaces = 10
faceValue = 8

behavior:
roll()  
getFaceValue()
```

#### Die Class

The following code creates a new class named Die

```py
class Die:
  faceValue = 0
  def __init__(self,faces):  
    self.numFaces = faces
```

Each Die object contains two pieces of data: numFaces, faceValue

No behavior (yet)

#### Instance Variables

Each object has its own copy of instance variable

Declaring an instance variable:

<name\> = <value\>

```py
class Die:
  faceValue = 0
  def __init__(self,faces):
    self.numFaces = faces
```

Each Die object maintains its own `numFaces` and `faceValue` variable, and thus its own state

die1 = Die(5)  # numFaces = 5

die2 = Die(6)  # numFaces = 6

#### Accessing Instance Variables

Code in other classes can access your object's instance variables

• Accessing an instance variable: dot operator

```py
<variable name>.<instance variable>
```

• Modifying an instance variable:

```py
<variable name>.<instance variable> = <value>
```

Examples:

```py
>>> print ("you rolled", die.faceValue)  
die.faceValue = 20
```

#### Client Code

Die and snakeEyes can have a main

• This is used to test the class before it is used by other classes

or can be used by other programs stored in separate .py files

• client code: Code that uses a class

```py
#Roll.py (client code)

def main():
  s = SnakeEyes(5000)
  s.rollingDie()

if name == "_main_":  
  main()
```

```py
#snakeEyes.py

class SnakeEyes:
  def __init__(self,num_rolls):  
    self.rolls = num_rolls  
    self.count = 0
```

#### Rolling the Dice: Python Program

```py
class SnakeEyes:
  def __init__(self,num_rolls):     
    self.rolls = num_rolls     
    self.count = 0

  def rollingDie(self):  
    die1 = Die(6)     
    die2 = Die(6)

    for i in range(self.rolls):      
      face1Val = die1.roll()      
      face2Val = die2.roll()
      if face1Val == 1 and face2Val == 1:     
        self.count += 1

    print("Num Snake Eyes: ",self.count)
    print("Num Rolls: ",self.rolls)
    print("Snake eyes probability: ", self.count/self.rolls)
```

```py
class Die:
  faceValue = 0

  def __init__(self,faces):  
    self.numFaces = faces

  def roll(self):
    faceValue = random.randrange(1,self.numFaces + 1)
    return faceValue
```

```py
def main():
  s = SnakeEyes(5000)  
  s.rollingDie()

if name == "_main_":  main()
```

#### Operator Overloading

operator overloading: You can define functions so that Python's built-in operators can be used with your class

Operator|Class Method
:--:|:--:
-|`__neg__(self, other)`
+|`__pos__(self, other)`
*|`__mul__(self, other)`
/|`__truediv__(self, other)`

Unary Operators|Class Method
:--:|:--:
-|`__neg__(sself)`
+|`__pos__(self)`

Operator|Class Method
:--:|:--:
==|`__eq__(self, other)`
!=|`__ne__(self, other)`
<|`__lt__(self, other)`
>|`__gt__(self, other)`
<=|`__le__(self, other)`
>=|`__ge__(self, other)`

### "Private" Attributes

#### Public Attributes

Public attribute: any other class or function can see and change the attribute

Public method: any other class or function can call the method

Python attributes and methods are public by default

• It does not really have encapsulation or private fields

• relies on caller to "be nice" and not mess with object contents

• Attributes may be public or private (although due to their specific implementation, they are not truly private in Python)

#### Private Attributes

Mark attributes and methods (somewhat) private by adding \_\_ (two underscores) to the beginning of the name, but none at the end

• Note: Names with two underscores at the beginning and the end are for built-in methods or attributes for the class

```py
self.__radius = 20  # Private attribute
def __method1():  # Private method
```

#### Hiding a Private Attribute

```py
class Student:
  """A class representing a student """

  def __init__(self,n,a):
    self.full_name = n
    self.__age = a # marked private

  def get_age(self):
    return self.__age


student1 = Student("John", 20)
age = student1.age # AttributeError: `Student’ object has no attribute ‘age’

age = student1.__age # 'Student' object has no attribute '__age'

age = student1._Student__age #20
#So, it is possible to access private data in Python,
#but it is difficult and good programmers know not to do it.
#Using the defined interface methods (getters and setters)
#will make code more maintainable and safer to use
```

#### Getter and Setter Methods

A coding convention

Getters/Accessors: methods that return an attribute value

```py
def get_name(self):
```

Setters/Mutators: methods that set an attribute value

```py
def set_name(self, newName):
```

#### Getter Methods

Why use getters? What if later I want to store the name instead as first and last name in the class? Well, with the getter I only have to do this:

```py
def get_name(self):
  return self.firstname + self.lastname
```

If I had used dot notation outside the class, then all the code OUTSIDE the class would need to be changed because the internal structure INSIDE the class changed

#### Setter Methods

Why use setters? Same reason as getters plus one more!

What if I want to add validation? For example, no age can be over 200 or below 0. If we use dot notation, it is difficult to enforce it. With setters:

```py
def setAge(self, age):
  if age > 200 or age < 0:
    # show error
  else:
    self.age = age
```

Getters and setters are useful to provide data encapsulation and should be used

Example:

```py
class Cars():
  def __init__(self, model, color, year):
    self.model = model
    self.color = color
    self.year = year
    self.kind = 'Automobile'
    self.behavior = []     #starts out as empty list
  def add_behavior(self, move):
    self.behavior.append(move)

--------
>>> c1 = Cars('Toyota','Sliver','2009')
>>> print(c1.model, c1.color, c1.year)
Toyota Sliver 2009

>>> c1.add_behavior('start')
>>> print(c1.behavior)
['start']

>>> c2 = Cars('Honda','White','2010')
>>> print(c2.model, c2.color, c2.year)
Honda White 2010

>>> c2.add_behavior('accelerate')
>>> print(c2.behavior)
['accelerate']
```
#### Setter: Generating Exceptions

raise ExceptionType("message")

Useful when the client uses your object improperly

• types: ArithmeticError, AssertionError, IndexError, NameError, SyntaxError, TypeError, ValueError

Example

```py
class BankAccount:
  ...
  def deposit(self, amount):
    if amount < 0:
      raise ValueError("negative amount")
      ...
```

### Access to Unknown Attributes and Methods

#### Traditional Syntax for Access

```py
class Student:
  '''A class representing a student '''
  def __init__(self,n,a):
    self.full_name = n
    self.age = a
  def get_age(self):
    return self.age

---------
>>> f = Student("Bob Smith", 23)
>>> f.full_name # Access instance attribute
"Bob Smith"
>>> f.get_age() # Access a method
23

```
#### Accessing Unknown Members

Problem:  Occasionally the name of an attribute or method of a class is only given at run time…

• Solution

```py
getattr(object_instance, string)
```

• string is a string which contains the name of an attribute or method of a class

• getattr(object_instance, string) returns a reference to that attribute or method


```py
>>> f = Student("Bob Smith", 23)

>>> getattr(f, "full_name")
"Bob Smith"

>>> getattr(f, "get_age")
 <method get_age of class studentClass at 010B3C2>

>>> getattr(f, "get_age")() # call it
23

>>> getattr(f, "get_birthday")
# Raises AttributeError – No method!
```

#### hasattr(object_instance,string)

```py
>>> f = Student(“Bob Smith”, 23)

>>> hasattr(f, “full_name”)
True

>>> hasattr(f, “get_age”)
True

>>> hasattr(f, “get_birthday”)
False
```

### Inheritance

#### Subclass: Extend a Class Definition

A class can extend the definition of another class

• Allows use (or extension ) of methods and attributes already defined in the previous one

• New class: subclass.
• Original: superclass, parent, or ancestor

To define a subclass, put the name of the superclass in parentheses after the subclass’s name on the first line of the definition.

   `class CS_Student(Student):`

• Python has no ‘extends’ keyword like Java

• Multiple inheritance is supported

#### Inheritance

```py
class name(superclass):
    statements
```

Example

```py
class Point3D(Point):   # Point3D extends Point
  z = 0
  ...
```

Python also supports multiple inheritance

```py
class name(superclass, ..., superclass):
    statements

#if > 1 superclass has the same field/method, conflicts are resolved in left-to-right order
```

#### Calling Superclass Methods

methods:	`class.method(object, parameters)`

constructors:	`class.__init__(self, parameters)`

```py
class Point3D(Point):
  z = 0
  def __init__(self, x, y, z):
    Point.__init__(self, x, y)
	  self.z = z

  def translate(self, dx, dy, dz):
    Point.translate(self, dx, dy)
	  self.z += dz
```

#### Redefining Methods

To redefine a method of the superclass, include a new definition using the same name in the subclass

• The old code won’t get executed

To execute the method in the parent class in addition to new code for some method, explicitly call the parent’s version of the method

`parentClass.methodName(self, a, b, c)`

The only time you ever explicitly pass ‘self’ as an argument is when calling a method of an ancestor

#### Example: Extending Student

```py
class Student:
  "A class representing a student.""
	def __init__(self,n,a):
    self.full_name = n
    self.age = a

	def get_age(self):
    return self.age

------

class CS_student (Student):
  "A class extending Student."
  def __init__(self,n,a,s):
    student.__init__(self,n,a) #Call __init__ for student
	  self.section_num = s

  def get_age(): 	#Redefines get_age method entirely
    print “Age: ” + str(self.age)
```

#### Extending __init__

Same as for redefining any other method…

• Commonly, the ancestor’s __init__ method is executed in addition to new commands

• You’ll often see something like this in the __init__ method of subclasses

```py
parentClass.__init__(self, x, y)
```

 where parentClass is the name of the parent’s class

## Chapter 5 NumPy

#### Outline

Arrays

Shaping and transposition

Mathematical Operations

Indexing and slicing

Broadcasting

#### NumPy Documentation

Official documentation

http://docs.scipy.org/doc/

The NumPy book

http://www.tramy.us/numpybook.pdf

Example list

http://www.scipy.org/Numpy_Example_List_With_Doc

#### Limitations of Lists

Lists ok for storing small amounts of one-dimensional data

```py
>>> a = [1,3,5,7,9]
>>> print(a[2:4])
[5, 7]

>>> b = [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]]
>>> print(b[0])
[1, 3, 5, 7, 9]

>>> print(b[1][2:4])
[6, 8]

>>> a = [1,3,5,7,9]
>>> b = [3,5,6,7,9]
>>> c = a + b
>>> print c
[1, 3, 5, 7, 9, 3, 5, 6, 7, 9]
```

But, can’t use directly with arithmetical operators (+, -, *, /, …)

Need efﬁcient arrays with arithmetic and better multidimensional tools

Numpy is similar to lists, but much more capable, except ﬁxed size

```py
>>> import numpy
```

#### What is NumPy?

NumPy is the fundamental package needed for scientific computing with Python. It contains:

• a powerful N-dimensional array object

• basic linear algebra functions

• basic Fourier transforms

• sophisticated random number capabilities

• tools for integrating Fortran code

• tools for integrating C/C++ code

#### NumPy

Fundamental package for scientific computing in Python

A Python library that provides

• A multidimensional array object

• Various derived objects (such as masked arrays and matrices)

• An assortment of routines for fast operations on arrays, including: mathematical, Logical, Shape manipulation, Sorting, Selecting, I/O, Discrete Fourier transforms, Basic linear algebra, Basic statistical operations, Random simulation and much more

#### Why NumPy?

Python does numerical computations slowly

1000 x 1000 matrix multiply:

• Python triple loop takes > 10 min.

• NumPy takes ~0.03 seconds

#### The ndarray Class

NumPy adds a new class to Python – the ndarray

• An N-dimensional array is a homogeneous collection of “items” indexed using N integers

• Defined by:

1. the shape of the array, and

2. the kind of item the array is composed of

#### Array Shape

ndarrays are rectangular

The shape of the array is a tuple of N integers (one for each dimension)

#### Real-life Data Modeled by ndarray

Structured lists of numbers

• Vectors

$$\begin{bmatrix} p_{x}\\ p_{y}\\ p_{z}\end{bmatrix}$$

• Matrices

$$\begin{bmatrix} a_{11} & ... & a_{1n}\\ ... & ... & ...\\ a_{m1} & ... & a_{mn}\end{bmatrix}$$

• Images
<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/daodao.jpg" width="200">

• Tensors

<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/tensor.png" width="200">

• ConvNets (Convolutional Neural Networks (CNNs))

<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/cnn.png" width="230">

#### Arrays, Basic Properties

Arrays can have any number of dimensions, including zero (a scalar)

Arrays are typed: np.uint8, np.int64, np.float32, np.float64...

Arrays are dense. Each element of the array exists and has the same type

### Arrays: Attributes

#### ndarray Attributes

ndarray.ndim

• number of axes (dimensions) of the array i.e., the rank

ndarray.shape

• dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with n rows and m columns, shape will be (n,m). The length of the shape tuple is therefore the rank, or number of dimensions, ndim

ndarray.size

• total number of elements of the array, equal to the product of the elements of shape

ndarray.dtype

• the type of the elements in the array. One can create or specify dtypes using standard Python types. NumPy provides many, for example, bool_, character, int_, int8, int16, int32, int64, float_, float8, float16, float32, float64, complex_, complex64, object_

ndarray.itemsize

• size in bytes of each element of the array. E.g. for elements of type float64, itemsize is 8 (=64/8), while complex32 has itemsize 4 (=32/8) (equivalent to ndarray.dtype.itemsize)

ndarray.data

• buffer containing the actual elements of the array. Normally, we won't need to use this attribute because we will access the elements in an array using indexing facilities

#### NumPy dtypes

Basic Type|Available NumPy types|Comments
:--:|:--:|:--:
Boolean|bool|Elements are 1 byte in size
Integer|int8, int16, int32, int64, int128, int|int defaults to the size of int in C for the platform
Unsigned Integer|uint8, uint16, uint32, uint64, uint128, uint| uint defaults to the size of unsigned int in C for the platform
Float|float32, float64, float, longfloat|Float is always a double precision floating point value (64 bits). longfloat represents large precision floats. Its size is platform dependent.
Complex|complex64, complex128, complex|The real and complex elements of a complex64 are each represented by a single precision (32 bit) value for a total size of 64 bits.
Strings|str, unicode|Unicode is always UTF32 (UCS4)
Object|object|Represent items in array as Python objects.
Records|void|Used for arbitrary data structures in record arrays.

#### Examples

```py
>>> import numpy as np
>>> x = np.array([1,2,3,4])
>>> x
array([1,2,3,4])

>>> print(x)
[1,2,3,4]

>>> x.ndim
1

>>> x.dtype
dtype('int32')

>>> x.shape
(4,)

>>> x.size
4

>>> x.itemsize
4
```

#### Multi-Dimensional Arrays

```py
>>> a = np.array([[ 0, 1, 2, 3], [10,11,12,13]])

>>> a
array([[ 0, 1, 2, 3], [10,11,12,13]])

#(ROWS,COLUMNS)
>>> a.shape
(2, 4)

>>> np.shape(a)
(2, 4)

#ELEMENT COUNT
>>> a.size
8

>>> np.size(a)
8

#NUMBER OF DIMENSIONS
>>> a.ndim
2

#GET/SET ELEMENTS
>>> a[1,3]
13

>>> a[1,3] = -1
>>> a
array([[ 0, 1, 2, 3],[10,11,12,-1]])

#ADDRESS FIRST ROW USING SINGLE INDEX
>>> a[1]
array([10, 11, 12, -1])
```

### Arrays: Creation

#### Arrays: Creation

• np.array: List all elements

• np.empty, np.ones, np.zeros, np.full, np.eye: Specify shape as tuple

• np.empty_like, np.zeros_like, np.ones_like: Specify shape by example

• np.arange: Specify shape & range

• np.concatenate

• np.astype: Change data type

• np.random.random

#### np.array()

np.array (from lists)

```py
>>> import numpy as np
>>> x = np.array([1,2,3,4])
>>> x
array([1, 2, 3, 4])
```
```py
>>> l = [[1, 2, 3], [3, 6, 9], [2, 4, 6]] # create a list
>>> a = np.array(l) # convert a list to an array

>>>print(a)
[[1 2 3]
[3 6 9]
[2 4 6]]

>>> a.shape
(3, 3)

>>> print(a.dtype) # get type of an array
int32
```
```py
#only one type
>>> a[0,0] = "hello"
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [16], in <cell line: 1>()
----> 1 a[0,0] = "hello"

ValueError: invalid literal for int() with base 10: 'hello'
```
```py
>>> np.array([[1, 2], [3, 4]], dtype=complex)
array([[ 1.+0.j, 2.+0.j],[ 3.+0.j, 4.+0.j]])
```

#### np.zeros()

```py
>>> np.zeros((3,4))
array([[0., 0., 0., 0.],
       [0., 0., 0., 0.],
       [0., 0., 0., 0.]])

>>> np.zeros((6,2), dtype=np.int8)
array([[0, 0],
       [0, 0],
       [0, 0],
       [0, 0],
       [0, 0],
       [0, 0]], dtype=int8)
```

#### np.ones()

```py
>>> np.ones((4,5))
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]])

>>> np.ones((3,5), dtype=np.float32)
array([[1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.],
       [1., 1., 1., 1., 1.]], dtype=float32)
```

#### np.full()

```py
>>> np.full((3,5),5)
array([[5, 5, 5, 5, 5],
       [5, 5, 5, 5, 5],
       [5, 5, 5, 5, 5]])
```

#### np.eye()

```py
>>> np.eye(5,5)
array([[1., 0., 0., 0., 0.],
       [0., 1., 0., 0., 0.],
       [0., 0., 1., 0., 0.],
       [0., 0., 0., 1., 0.],
       [0., 0., 0., 0., 1.]])
```

#### np.zeros_like()

Returns a new array with the same shape and type as a given
array. Array is initialized to zeroes

```py
>>> a = np.ones((2,2,3))
>>> np.zeros_like(a)
array([[[0., 0., 0.],
        [0., 0., 0.]],

       [[0., 0., 0.],
        [0., 0., 0.]]])
```

#### np.empty_like

```py
>>> np.ones_like(a)
array([[[1., 1., 1.],
        [1., 1., 1.]],

       [[1., 1., 1.],
        [1., 1., 1.]]])
```

#### np.empty_like

```py
>>> np.empty_like(a)
array([[[0., 0., 0.],
        [0., 0., 0.]],

       [[0., 0., 0.],
        [0., 0., 0.]]])
```

#### np.arange

```py
np.arange(1334, 1338)
array([1334, 1335, 1336, 1337])
```

#### np.concatenate

The default axis for concatenation is along axis 0

The other dimension(s) should match

```py
>>> a = np.ones((2,3))
>>> b = np.zeros((4,3))
>>> np.concatenate([a,b])
array([[1., 1., 1.],
       [1., 1., 1.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.],
       [0., 0., 0.]])
```

Will give error if we try to concatenate along axis 0

```py
>>> a = np.ones((4,1))
>>> b = np.zeros((4,2))
>>> np.concatenate([a,b])
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Input In [31], in <cell line: 3>()
      1 a = np.ones((4,1))
      2 b = np.zeros((4,2))
----> 3 np.concatenate([a,b])

File <__array_function__ internals>:180, in concatenate(*args, **kwargs)

ValueError: all the input array dimensions for the concatenation axis must match exactly, but along dimension 1, the array at index 0 has size 1 and the array at index 1 has size 2
```

But we can change axis to 1

```py
>>> a = np.ones((4,1))
>>> b = np.zeros((4,2))
>>> np.concatenate([a,b], axis = 1)
array([[1., 0., 0.],
       [1., 0., 0.],
       [1., 0., 0.],
       [1., 0., 0.]])
```

#### np.astype

astype(): used for data type casting

float32 ⟶ uint16: truncates the fractional part

```py
>>> a = np.full((5,5),3.14)
>>> a
array([[3.14, 3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14, 3.14]])

>>> a.astype(np.uint16)
array([[3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3],
       [3, 3, 3, 3, 3]], dtype=uint16)
```

#### np.random.random()

```py
>>> np.random.random((10,3))
array([[0.93003514, 0.57601937, 0.66949356],
       [0.57035166, 0.71226342, 0.13910904],
       [0.3992838 , 0.54045372, 0.29492326],
       [0.62259197, 0.37809815, 0.4305206 ],
       [0.15510728, 0.90654721, 0.02204135],
       [0.62912287, 0.5479325 , 0.408733  ],
       [0.62130821, 0.34540678, 0.97622495],
       [0.91248238, 0.12212246, 0.88548726],
       [0.4615713 , 0.51269651, 0.01157459],
       [0.90006977, 0.0449222 , 0.14394594]])
```

#### Danger Zone

Must be dense, no holes

Must be one type

Cannot combine arrays of different shape

#### Arrays: reshape()

```py
>>> import numpy as np
>>> x = np.array([1,2,3,4])
>>> x
array([1, 2, 3, 4])

>>> x.shape
(4,)

>>> x.shape[0]
4

>>> x = x.reshape(1,x.shape[0])
>>> x
array([[1, 2, 3, 4]])

>>> x.shape
(1, 4)

>>> x[0,2]
3

>>> np.arange(10)
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

>>> np.array(np.arange(10)).reshape(2,5)
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
```

### Array Operations

#### Return Values

NumPy functions return either views or copies

Views share data with the original array, like references in Java/C++. Altering entries of a view, changes the same entries in the original

np.copy, np.view make explicit copies and views, respectively

#### Array Views and Copies

Two ndarrays are mutable and may be views to the same memory:

```py
>>> x = np.array([1,2,3,4])
>>> y = x
>>> x is y
True

#The id() method returns a unique integer (identity) of a passed argument object.
>>> id(x), id(y)
(2463893013200, 2463893013200)

>>> x[0] = 9
>>> y
array([9, 2, 3, 4])

>>> x[0] = 1
>>> z = x[:]
>>> x is z
False

>>> id(x), id(z)
(2463893013200, 2463893014448)

>>> x[0] = 8
>>> z
array([8, 2, 3, 4])
```
```py
>>> x = np.array([1,2,3,4])
>>> y = x.copy()
>>> x is y
False

>>> id(x), id(y)
(2463893022992, 2463893027888)

>>> x[0] = 9
>>> x
array([9, 2, 3, 4])

>>> y
array([1, 2, 3, 4])
```

#### Array Slicing

<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/slicing.png" width="200">

```py
#Slicing works much like Standard Python Slicing
>>> a[0,3:5]
array([3, 4])

>>> a[4:,4:]
array([[44, 45], [54, 55]])

>>> a[:,2]
array([2,12,22,32,42,52])

# Strides are also possible
>>> a[2::2,::2]
array([[20, 22, 24], [40, 42, 44]])
```

#### Array Slicing Examples

```py
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])

>>> a[:4]
array([0, 1, 2, 3])

>>> a[:10:2]
array([0, 2, 4, 6, 8])

>>> a[::3]
array([0, 3, 6, 9])

>>> a[2::3]
array([2, 5, 8])

>>> a[5:] = 20
>>> a
array([ 0,  1,  2,  3,  4, 20, 20, 20, 20, 20])

>>> y = np.arange(5)
>>> y
array([0, 1, 2, 3, 4])

>>> a[5:] = y[::-1]
>>> a
array([0, 1, 2, 3, 4, 4, 3, 2, 1, 0])

>>> x = np.array([[10,20,30,40],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10,  20,  30,  40],
       [ 50,  60,  70,  80],
       [ 90, 100, 110, 120]])

>>> x[1,:]
array([50, 60, 70, 80])

>>> x[:2,:]
array([[10, 20, 30, 40],
       [50, 60, 70, 80]])

>>> x[:,2]
array([ 30,  70, 110])

# Reverse rows
>>> x[::-1,]
array([[ 90, 100, 110, 120],
       [ 50,  60,  70,  80],
       [ 10,  20,  30,  40]])

# Reverse columns
>>> x[:,::-1]
array([[ 40,  30,  20,  10],
       [ 80,  70,  60,  50],
       [120, 110, 100,  90]])

>>> x[::-1,::-1]
array([[120, 110, 100,  90],
       [ 80,  70,  60,  50],
       [ 40,  30,  20,  10]])
```

#### Infinity and NaN

```py
>>> x = np.array([[10.0,20.0,30.0,40.0],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,  70.,  80.],
       [ 90., 100., 110., 120.]])

>>> x[2,1] = np.nan
>>> x[1,2] = np.inf
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,  inf,  80.],
       [ 90.,  nan, 110., 120.]])
```

#### Fancy Indexing

```py
# Indexing By Position
>>> a = np.arange(0,80,10)
>>> a
array([ 0, 10, 20, 30, 40, 50, 60, 70])

>>> y = a[1, 2, -3] # error; too many indices
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Input In [86], in <cell line: 1>()
----> 1 y = a[1, 2, -3]

IndexError: too many indices for array: array is 1-dimensional, but 3 were indexed
```

```py
# fancy indexing
>>> y = a[[1, 2, -3]]
>>> print (y)
[10 20 50]

# using take

>>> y = np.take(a,[1,2,-3])
>>> print (y)
[10 20 50]
```

<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/indexing.png" width="200">

```py
# Indexing With Booleans

>>> mask = np.array([0,1,1,0,0,1,0,0], dtype=bool)

# fancy indexing
>>> y = a[mask]
>>> print (y)
[10,20,50]

# using compress
>>> y = np.compress(mask, a)
>>> print (y)
[10,20,50]
```

#### Fancy Indexing in 2D

Unlike slicing, fancy indexing creates copies instead of views into original arrays

<img src="https://joy3luo.github.io/mathnotes/pics/MSML605/2d.png" width="200">

```py
>>> a[(0,1,2,3,4),(1,2,3,4,5)]
array([ 1, 12, 23, 34, 45])

>>> a[3:,[0, 2, 5]]
array([[30, 32, 35],
       [40, 42, 45]])
       [50, 52, 55]])

>>> mask = array([1,0,1,0,0,1], dtype=bool)
>>> a[mask,2]
array([2,22,52])
```

```py
>>> x = np.array([[10,20,30,40],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10,  20,  30,  40],
       [ 50,  60,  70,  80],
       [ 90, 100, 110, 120]])

>>> y = np.array([0,3,1])
>>> y
array([0, 3, 1])

>>> x[np.arange(3),y] # x[array([0, 1, 2]), array([0, 3, 1])]
array([ 10,  80, 100]) # array([x[0,0], x[1,3], x[2,1]])

>>> x[np.arange(3),y]*4
array([ 40, 320, 400])
```

#### Array Mask

```py
>>> x = np.array([[10.0,20.0,30.0,40.0],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,  70.,  80.],
       [ 90., 100., 110., 120.]])

>>> x[2,1] = np.nan
>>> x[1,2] = np.inf
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,  inf,  80.],
       [ 90.,  nan, 110., 120.]])

>>> missing_boolean = np.isnan(x) | np.isinf(x)
>>> missing_boolean
array([[False, False, False, False],
       [False, False,  True, False],
       [False,  True, False, False]])

>>> x[missing_boolean] = 0
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,   0.,  80.],
       [ 90.,   0., 110., 120.]])

>>> y = x
>>> y
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,   0.,  80.],
       [ 90.,   0., 110., 120.]])
```

#### Making Copies

```py
>>> y[1,2] = 255
>>> x
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60., 255.,  80.],
       [ 90.,   0., 110., 120.]])

>>> z = x.copy()
>>> z
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60., 255.,  80.],
       [ 90.,   0., 110., 120.]])

>>> z[1,2] = 0
>>> z
array([[ 10.,  20.,  30.,  40.],
       [ 50.,  60.,   0.,  80.],
       [ 90.,   0., 110., 120.]])
```

#### Random Numbers

```py
>>> np.random.rand(5)
array([0.61053439, 0.33437535, 0.62285413, 0.98721938, 0.29950438])

>>> np.random.rand(5,5)
array([[0.12712546, 0.91354213, 0.50871145, 0.44210558, 0.30280345],
       [0.35090259, 0.71408646, 0.60706742, 0.76499   , 0.7466076 ],
       [0.16686667, 0.03115689, 0.73075451, 0.81330552, 0.73375856],
       [0.60259952, 0.65025317, 0.68710329, 0.73775431, 0.25808089],
       [0.95265036, 0.64556015, 0.2861022 , 0.95552397, 0.49191597]])

# 3 random integers between 0 and 24
>>> np.random.randint(0,25,3)
array([11,  8,  5])

>>> np.random.seed(1)
>>> np.random.randint(0,25,3)
array([ 5, 11, 12])

>>> np.random.normal(1.0,3.0,5) # mean = 1.0, std dev = 3.0
array([-3.80516301, -3.43348871,  2.45048754,  1.56530982, -0.39405897])

>>> np.random.uniform(5,10,4) # low = 5, high = 10
array([5.21027354, 9.85016485, 5.73331773, 9.01273927])

>>> np.linspace(1,100,15) # every spaced over interval [1, 100]
array([  1.        ,   8.07142857,  15.14285714,  22.21428571,
        29.28571429,  36.35714286,  43.42857143,  50.5       ,
        57.57142857,  64.64285714,  71.71428571,  78.78571429,
        85.85714286,  92.92857143, 100.        ])

>>> np.random.sample(5) #random floats in interval [0.0, 1.0]
array([0.97981828, 0.98077621, 0.46954487, 0.8922581 , 0.48710491])
```

### Mathematical Operations

#### Mathematical Operations

Arithmetic operations are element-wise

Logical operator return a bool array

In place operations modify the array

#### Math, Universal Functions

Also called ufuncs

Operates element-wise

Examples:

• np.exp()

• np.sqrt()

• np.sin()

• np.cos()

• np.isnan()

#### Array – Multiply By Constant

```py
>>> x = np.array([[10,20,30,40],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10,  20,  30,  40],
       [ 50,  60,  70,  80],
       [ 90, 100, 110, 120]])

>>> x*3
array([[ 30,  60,  90, 120],
       [150, 180, 210, 240],
       [270, 300, 330, 360]])

>>> x/3
array([[ 3.33333333,  6.66666667, 10.        , 13.33333333],
       [16.66666667, 20.        , 23.33333333, 26.66666667],
       [30.        , 33.33333333, 36.66666667, 40.        ]])
```

#### Array Boolean Operations

```py
>>> x = np.array([[10,20,30,40],[50,60,70,80],[90,100,110,120]])
>>> x
array([[ 10,  20,  30,  40],
       [ 50,  60,  70,  80],
       [ 90, 100, 110, 120]])

>>> y = x>30
>>> y
array([[False, False, False,  True],
       [ True,  True,  True,  True],
       [ True,  True,  True,  True]])

>>> x[y]
array([ 40,  50,  60,  70,  80,  90, 100, 110, 120])
```

#### More Examples

```py
>>> a = np.arange(4.0)
>>> a
array([0., 1., 2., 3.])

>>> b = a * 23.4
>>> b
array([ 0. , 23.4, 46.8, 70.2])

>>> c = b/(a+1)
>>> c
array([ 0.  , 11.7 , 15.6 , 17.55])

>>> c += 10
>>> print(c)
[ 10. 21.7 25.6 27.55]
```

```py
>>> arr = np.arange(100, 200)
>>> arr
array([100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
       113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
       126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,
       139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151,
       152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
       165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
       178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
       191, 192, 193, 194, 195, 196, 197, 198, 199])

>>> select = [5, 25, 50, 75, -5]
>>> print(arr[select]) # can use integer lists as indices
[105, 125, 150, 175, 195]
```

```py
>>> arr = np.arange(10, 20)
>>> arr
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

>>> div_by_3 = arr%3 == 0 # comparison produces boolean array
>>> print(div_by_3)
[ False False True False False True False False True False]

>>> print(arr[div_by_3]) # can use boolean lists as indices
[12 15 18]
```

#### NumPy Math: add()

```py
import numpy as np
>>> a = np.array([[10,20],[30,40]],dtype = np.int64)
>>> a
array([[10, 20],
       [30, 40]], dtype=int64)
```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```

####



```py

```
